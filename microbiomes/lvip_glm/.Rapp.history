library(help='gnfinderr')
gnfinder
?gnfinder
host <- sapply(parsed_list, function(x) {#
#
  quals <- x$`GBSeq_feature-table`$GBFeature$GBFeature_quals#
  if(!is.null(quals)) {#
    for(y in quals) {#
      if(y[[1]] == 'host') return(y[[2]])#
    }#
  }#
#
})#
#
host_gnfinder <- gnfinderr::gnfinder(host, check_names=FALSE)
host_gnfinder <- gnfinderr::gnfinder(unique(host), check_names=FALSE)
gnfinder
?glue
host_gnfinder <- sapply(unique(host), function(x) glue::glue("echo {double_quote(x)} | gnfinder"))
host_gnfinder <- sapply(unique(host), function(x) glue::glue("echo {x} | gnfinder"))
host_gnfinder
gnfinder
host_gnfinder <- sapply(unique(host), function(x) paste0("echo ",x,"" | gnfinder"))
)
""
host_gnfinder <- sapply(unique(host), function(x) paste0("echo ",x," | gnfinder"))
head(host_gnfinder)
host_gnfinder <- sapply(unique(host), function(x) map(paste0("echo ",x," | gnfinder"), system))
?map
host_gnfinder <- sapply(unique(host), function(x) system(paste0("echo ",x," | gnfinder")))
gnfinder
host_gnfinder <- sapply(unique(host), function(x) system(paste0("echo ",x," | gnfinder")), intern=TRUE)
?system
host_gnfinder <- sapply(unique(host), function(x) system(paste0("echo ",x," | gnfinder"), intern=TRUE))
host_gnfinder[[1]]
host_gnfinder <- sapply(unique(host), function(x) system(paste0('echo \'',x,'\' | gnfinder'), intern=TRUE))
host_gnfinder
host_gnfinder <- sapply(unique(host), function(x) strsplit(system(paste0('echo \'',x,'\' | gnfinder'), intern=TRUE)[[2]], ',')[[3]])
host_gnfinder <- sapply(unique(host), function(x) {#
  output <- system(paste0('echo \'',x,'\' | gnfinder'), intern=TRUE)#
  if(length(output) > 1) return(strsplit(output[[2]], ',')[[3]])#
})
host_gnfinder <- sapply(unique(host), function(x) {#
  output <- system(paste0('echo \'',x,'\' | gnfinder'), intern=TRUE)#
  if(length(output) > 1) return(strsplit(output[[2]], ','))#
})
host_gnfinder <- sapply(unique(host), function(x) {#
  output <- system(paste0('echo \'',x,'\' | gnfinder'), intern=TRUE)#
  if(length(output) > 1) return(strsplit(output[[2]], ',')[[1]][[3]])#
})
host_gnfinder
library(worms)
wormsbyname(host_gnfinder)
wormsbynames(host_gnfinder)
wormsbynames(unlist(host_gnfinder))
wormsnames <- wormsbynames(unlist(host_gnfinder))
wormsnames <- wormsbymatchnames(unlist(host_gnfinder))
dim(wormsnames)
colnames(wormsnames)
wormsnames$scientificname
? wormsbymatchnames
wormsbymatchnames
?worrms
library(help='worrms')
? wm_records_taxamatch
? worrms::wm_records_taxamatch
wormsnames <- worrms:: wm_records_taxamatch(unlist(host_gnfinder))
wormsnames[[1]]
wormsnames[[1]]$valid_name
wormsnames <- sapply(worrms::wm_records_taxamatch(unlist(host_gnfinder)), function(x) x$valid_name)
wormsnames
unlist(wormsnames)
host_gnfinder <- sapply(unique(host), function(x) {#
  output <- system(paste0('echo \'',x,'\' | gnfinder'), intern=TRUE)#
  if(length(output) > 1) return(worrms::wm_records_taxamatch(strsplit(output[[2]], ',')[[1]][[3]])$valid_name)#
})
host_gnfinder <- sapply(unique(host), function(x) {#
  output <- system(paste0('echo \'',x,'\' | gnfinder'), intern=TRUE)#
  if(length(output) > 1) return(strsplit(output[[2]], ',')[[1]][[3]])#
})#
#
wormsnames <- sapply(host_gnfinder, function(x) worrms::wm_records_taxamatch(x)$valid_name)
host_gnfinder <- sapply(unique(host), function(x) {#
  output <- system(paste0('echo \'',x,'\' | gnfinder'), intern=TRUE)#
  if(length(output) > 1) return(strsplit(output[[2]], ',')[[1]][[3]])#
})#
#
wormsnames <- sapply(host_gnfinder, function(x) wait(0.1); worrms::wm_records_taxamatch(x)$valid_name)
wormsnames <- sapply(host_gnfinder, function(x) if(!is.null(x)) worrms::wm_records_taxamatch(x)$valid_name)
wormsnames
x <- names(host_gnfinder)[[1]]
x
output <- worrms::wm_records_taxamatch(host_gnfinder[x])
host_gnfinder[x]
output <- worrms::wm_records_taxamatch(host_gnfinder[x][[1]])
output <- worrms::wm_records_taxamatch(host_gnfinder[[x]])
output
x <- 45
x <- names(host_gnfinder)[[45]]
x
output <- worrms::wm_records_taxamatch(host_gnfinder[[x]])
host_gnfinder[[x]]
output <- worrms::wm_records_taxamatch('Homo')
wormsnames <- sapply(names(host_gnfinder), function(x) {#
  if(!is.null(host_gnfinder[[x]])) output <- try(worrms::wm_records_taxamatch(host_gnfinder[[x]]))#
  if(exists(output)) return(output$valid_name)#
})
wormsnames <- sapply(names(host_gnfinder), function(x) {#
  if(!is.null(host_gnfinder[[x]])) output <- try(worrms::wm_records_taxamatch(host_gnfinder[[x]]))#
  if(exists('output')) return(output$valid_name)#
})
?try
?tryCatch
wormsnames <- sapply(names(host_gnfinder), function(x) {#
  if(!is.null(host_gnfinder[[x]])) output <- tryCatch(worrms::wm_records_taxamatch(host_gnfinder[[x]]), error=NULL)#
  if(!is.null(output)) return(output$valid_name)#
})
wormsnames <- sapply(names(host_gnfinder), function(x) {#
  if(!is.null(host_gnfinder[[x]])) output <- tryCatch(worrms::wm_records_taxamatch(host_gnfinder[[x]]), error=function(e) NULL)#
  if(!is.null(output)) return(output$valid_name)#
})
wormsnames
x <- names(host_gnfinder)
x <- names(host_gnfinder)[[1]]
tryCatch(worrms::wm_records_taxamatch(host_gnfinder[[x]]), error=function(e) NULL)
output$valid_name
output[[1]]$valid_name
wormsnames <- sapply(names(host_gnfinder), function(x) {#
  output <- tryCatch(worrms::wm_records_taxamatch(host_gnfinder[[x]]), error=function(e) NULL)#
  if(!is.null(output)) return(output[[1]]$valid_name)#
})
wormsnames
??comm2sci
taxize::comm2sci('root knot nematodes')
taxize::comm2sci('sugarcane')
?taxize::comm2sci
taxize::comm2sci('sugarcane',dv='itis')
taxize::comm2sci('sugarcane',db='itis')
taxize::comm2sci('root knot nematodes',db='itis')
?match
head(host)
hostRaw <- host
host <- wormsnames[hostRaw]
head(host)
length(host)
tail(host)
wormsnames
taxize::comm2sci('coral',db='itis')
?entrez_fetch
? set_entrez_key
150000/77000000
*100
150000/77000000*100
10 % 2
10 %% 2
hostRaw <- sapply(final, function(x) {#
#
  quals <- x$`GBSeq_feature-table`$GBFeature$GBFeature_quals#
  if(!is.null(quals)) {#
    for(y in quals) {#
      if(y[[1]] == 'host') return(y[[2]])#
    }#
  }#
#
})
worrms::wm_records_taxamatch(c('human','Acroporidae'))
wormsnames <- sapply(worrms::wm_records_taxamatch(c('human','Acroporidae')), function(x) {#
    return(x$valid_name[[1]])#
})
wormsnames <- sapply(worrms::wm_records_taxamatch(host_gnfinder), function(x) {#
    if('valid_name' %in% colnames(x))#
        return(x$valid_name[[1]])#
})
wormsnames <- sapply(worrms::wm_records_taxamatch(c('human','Acroporidae')), function(x) {#
    if('valid_name' %in% colnames(x))#
        return(x$valid_name[[1]])#
})
wormsnames
library(help='worrms')
?worrms:: wm_records_names
?worrms:: wm_records_taxamatch
worrms:: wm_records_taxamatch
worrms:: wm_records_names
?worrms:: wm_records_common
wormsnames <- sapply(worrms::wm_records_common(c('human','Acroporidae')), function(x) {#
    if('valid_name' %in% colnames(x))#
        return(x$valid_name[[1]])#
})
wormsnames <- sapply(worrms::wm_records_common_(c('human','Acroporidae')), function(x) {#
    if('valid_name' %in% colnames(x))#
        return(x$valid_name[[1]])#
})
worrms::wm_records_common('human')
worrms::wm_records_common('soft coral')
worrms::wm_records_common('sponge')
worrms::wm_records_common('sponge',fuzzy=TRUE)
colnames(worrms::wm_records_common('sponge',fuzzy=TRUE))
worrms::wm_records_common('sponge',fuzzy=TRUE)$valid_name[[1]]
worrms::wm_records_common('sponge',fuzzy=TRUE)[1,]$valid_name[[1]]
worrms::wm_records_common('sponge',fuzzy=TRUE)[1,]
as.dataframe(worrms::wm_records_common('sponge',fuzzy=TRUE))
as.data.frame(worrms::wm_records_common('sponge',fuzzy=TRUE))
as.data.frame(worrms::wm_records_common('sea sponge',fuzzy=TRUE))
as.data.frame(worrms::wm_records_common('human',fuzzy=TRUE))
?worrms::wm_records_names
?worrms::wm_records_taxamatch
fungi_search <- rentrez::entrez_search('Nucleotide', 'fungi[Organism] AND strain[All Fields] AND host[All Fields]', use_history=TRUE)
length(fungi_search)
names(fungi_search)
fungi_search$count
cat(paste0(fungi_search$count, ' records to filter (', ceiling(fungi_search$count / 10000),' batches of 10000)\n'))
parsed_list_cumulative <- list()#
i <- 0#
batch <- 0
parsed_list_cumulative <- list()#
    host_raw_cumulative <- list()#
    wormsnames_cumulative <- list()#
    batch <- batch + 1
?rentrez::entrez_fetch
i <- 0
parsed_list<- XML::xmlToList(rentrez::entrez_fetch(db = "Nucleotide", web_history=fungi_search$web_history, rettype='gb', retmode='xml', retmax=10000, retstart=i, parsed=TRUE, seq_start=1, seq_stop=2))
fungi_search <- rentrez::entrez_search('Nucleotide', 'fungi[Organism] AND strain[All Fields] AND host[All Fields]', use_history=TRUE)
fungi_search
if (!requireNamespace("BiocManager", quietly = TRUE))#
    install.packages("BiocManager")#
#
BiocManager::install("metagenomeSeq")
?metagenomeseq::fitZeroLogNormal
?metagenomeSeq::fitZeroLogNormal
counts_fp <- '/Users/Ryan/Box Sync/Microbiome analysis TGH/santiago_asv_counts.tsv'
hi <- read.table(counts_fp)
hi[1:5,1:5]
dim(hi)
colnames(hi)
hi2 <- t(hi[,1:20])
rownames(hi)
rownames(hi2)
write.table(hi2, file='~/data/santiago/counts.txt', sep='\t')
hi2[1:5,1:5]
write.table(hi2, file='~/data/santiago/counts.txt', sep='\t', quote=FALSE)
PR <- sapply(rownames(hi2), grepl, 'R')
PR
PR <- sapply(rownames(hi2), grepl, '.*R.*')
PR
PR <- sapply(rownames(hi2), function(x) grepl('R',x))
PR
TP <- sapply(rownames(hi2), function(x) grepl('\.1',x))
TP <- sapply(rownames(hi2), function(x) grepl('\\.1',x))
TP
cbind(1,PR,TP)
mm <- cbind(1,PR,TP)
ag <- sapply(c(1,3,4,6,8), function(x) grepl(paste0('X',x),rownames(hi2)))
ag
mm <- cbind(1,PR,TP,ag)
mm
colnames(mm) <- c('intercept','rectal','time1','ind1','ind3','ind4','ind6','ind8')
mm
mm$time1 <- !mm$time1
mm$time1 <- 1-mm$time1
mm[,'time1'] <- 1-mm[,'time1']
mm
colnames(mm)[3] <- 'time2'
mm
write.table(mm,file='~/data/santiago/model_matrix.txt',sep='\t',quote=FALSE)
library(ape)
## get user-edited environmental variables output_prefix, phy_fp, counts_fp, and model_matrix_fp#
source(file.path(getwd(), 'lvip_glm.env'))#
###
#
## set up output directory#
dir.create(output_prefix)#
outfile <- file(file.path(output_prefix, 'runlog.log'), open = 'wt')#
sink(outfile, type = 'output', split = TRUE)#
###
#
counts <- read.table(counts_fp, sep='\t')#
modelMat <- read.table(model_matrix_fp, sep='\t')#
factorNames <- as.character(modelMat[1,])#
modelMat <- modelMat[-1,]#
idx <- sapply(factorNames, function(x) which(x == unique(factorNames)))
## get user-edited environmental variables output_prefix, phy_fp, counts_fp, and model_matrix_fp#
model_dir <- getwd()#
source(file.path(model_dir, 'lvip_glm.env'))#
###
#
## set up output directory#
dir.create(output_prefix)#
outfile <- file(file.path(output_prefix, 'runlog.log'), open = 'wt')#
sink(outfile, type = 'output', split = TRUE)#
###
#
counts <- as.matrix(read.table(counts_fp, sep='\t'))#
counts <- counts[,colSums(counts) > 0]#
modelMat <- read.table(model_matrix_fp, sep='\t')#
factorNames <- as.character(modelMat[1,])#
modelMat <- modelMat[-1,]#
idx <- sapply(factorNames, function(x) which(x == unique(factorNames)))#
#
library(ape)#
microbeTree <- chronoMPL(phytools::midpoint.root(read.tree(phy_fp)))
## get user-edited environmental variables output_prefix, phy_fp, counts_fp, and model_matrix_fp#
model_dir <- getwd()#
source(file.path(model_dir, 'lvip_glm.env'))#
###
#
## set up output directory#
dir.create(output_prefix)#
outfile <- file(file.path(output_prefix, 'runlog.log'), open = 'wt')#
sink(outfile, type = 'output', split = TRUE)#
###
#
counts <- as.matrix(read.table(counts_fp, sep='\t'))#
counts <- counts[,colSums(counts) > 0]#
modelMat <- read.table(model_matrix_fp, sep='\t')#
factorNames <- as.character(modelMat[1,])#
modelMat <- modelMat[-1,]#
idx <- sapply(factorNames, function(x) which(x == unique(factorNames)))#
#
library(ape)#
microbeTree <- chronoMPL(phytools::midpoint.root(read.tree(phy_fp)))#
microbeTree$edge.length[microbeTree$edge.length <= 0] <- min(microbeTree$edge.length[microbeTree$edge.length > 0])#
finalMicrobeTree <- reorder(drop.tip(microbeTree, microbeTree$tip.label[!microbeTree$tip.label %in% colnames(counts)]), 'pruningwise')#
#
counts <- counts[,finalMicrobeTree$tip.label]#
#
## generate some summary numbers regarding microbes#
microbeTips <- colnames(counts)#
NT <- length(microbeTips)#
NI <- finalMicrobeTree$Nnode#
NN <- NI + NT#
sa <- rbind(finalMicrobeTree$edge,c(0,NT+1))[NN:1,]#
time <- c(finalMicrobeTree$edge.length[1:length(finalMicrobeTree$tip.label)],1,finalMicrobeTree$edge.length[(length(finalMicrobeTree$tip.label)+1):length(finalMicrobeTree$edge.length)])#
#
###
NS <- nrow(modelMat)#
NSB <- length(unique(factorNames))#
NB_s <- ncol(modelMat)#
###
#
relabund <- diag(1/rowSums(counts)) %*% counts#
inv_log_max_contam <- 1 / log(max(apply(relabund, 2, function(x) max(x[x>0]) / min(x[x>0]))))#
standat <- list(NS                 = NS,#
                NI                 = NI,#
                NT                 = NT,#
                NB_s               = NB_s,#
                NSB                = NSB,#
                idx                = idx,#
                count              = t(counts),#
                time               = time,#
                self               = sa[,2],#
                ancestor           = sa[,1],#
                X_s                = modelMat,#
                inv_log_max_contam = inv_log_max_contam,#
                shape_gnorm        = 7)#
save.image(file.path(output_prefix, 'setup.RData'))#
#
sampling_command <- paste('./lvip_glm',#
                          paste0('data file=', file.path(output_prefix, 'data.json')),#
                          #paste0('init=', file.path(output_prefix, 'inits.json')),#
                          'output',#
                          paste0('file=', file.path(output_prefix, 'samples_sampling.csv')),#
                          paste0('refresh=', 1),#
                          'method=sample algorithm=hmc',#
                          'stepsize=1',#
                          'engine=nuts',#
                          'max_depth=10',#
                          'adapt t0=10',#
                          'delta=0.8',#
                          'kappa=0.75',#
                          #'init_buffer=10',#
                          #'window=2',#
                          'term_buffer=50',#
                          'num_warmup=1000',#
                          'num_samples=1000',#
                          ('opencl platform=0 device=0')[opencl],#
                          sep=' ')#
#
cmdstanr::write_stan_json(standat, file.path(output_prefix, 'data.json'))#
#
setwd(cmdstanr::cmdstan_path())#
system(paste0(c('make ', 'make STAN_OPENCL=true ')[opencl+1], 'STANCFLAGS="--include-paths=', model_dir, '" ', file.path(model_dir, 'lvip_glm')))#
#
setwd(model_dir)#
print(sampling_command)#
print(date())#
system(sampling_command)#
#
stan.fit <- cmdstanr::read_cmdstan_csv(file.path(output_prefix, 'samples_sampling.csv'),#
                                       format = 'draws_array')#
#
save.image(file.path(output_prefix, 'results.RData'))
exp(2)
x <- 2
0.5 * log(1-exp(x))
exp(x)
x <- 0.5
0.5 * log(1-exp(x))
exp(x)
x <- -2
exp(x)
0.5 * log(1-exp(x))
log(1-exp(0.5*x))
0.5 * log(1-exp(x))
## get user-edited environmental variables output_prefix, phy_fp, counts_fp, and model_matrix_fp#
model_dir <- getwd()#
source(file.path(model_dir, 'lvip_glm.env'))#
###
#
## set up output directory#
dir.create(output_prefix)#
outfile <- file(file.path(output_prefix, 'runlog.log'), open = 'wt')#
sink(outfile, type = 'output', split = TRUE)#
###
#
counts <- as.matrix(read.table(counts_fp, sep='\t'))#
counts <- counts[,colSums(counts) > 0]#
modelMat <- read.table(model_matrix_fp, sep='\t')#
factorNames <- as.character(modelMat[1,])#
modelMat <- modelMat[-1,]#
idx <- sapply(factorNames, function(x) which(x == unique(factorNames)))#
#
library(ape)#
microbeTree <- phytools::midpoint.root(read.tree(phy_fp))#
finalMicrobeTree <- reorder(drop.tip(microbeTree, microbeTree$tip.label[!microbeTree$tip.label %in% colnames(counts)]), 'pruningwise')#
finalMicrobeTree$edge.length <- finalMicrobeTree$edge.length / mean(phytools::nodeHeights(finalMicrobeTree)[finalMicrobeTree$edge[,2] <= length(finalMicrobeTree$tip.label),2])#
#
counts <- counts[,finalMicrobeTree$tip.label]#
#
## generate some summary numbers regarding microbes#
microbeTips <- colnames(counts)#
NT <- length(microbeTips)#
NI <- finalMicrobeTree$Nnode#
NN <- NI + NT#
sa <- rbind(finalMicrobeTree$edge,c(0,NT+1))[NN:1,]#
divergence <- finalMicrobeTree$edge.length[order(finalMicrobeTree$edge[,2])]#
#
###
NS <- nrow(modelMat)#
NSB <- length(unique(factorNames))#
NB_s <- ncol(modelMat)#
###
#
relabund <- diag(1/rowSums(counts)) %*% counts#
inv_log_max_contam <- 1 / log(max(apply(relabund, 2, function(x) max(x[x>0]) / min(x[x>0]))))#
standat <- list(NS                 = NS,#
                NI                 = NI,#
                NT                 = NT,#
                NB_s               = NB_s,#
                NSB                = NSB,#
                idx                = idx,#
                count              = t(counts),#
                divergence         = divergence,#
                self               = sa[,2],#
                ancestor           = sa[,1],#
                X_s                = modelMat,#
                inv_log_max_contam = inv_log_max_contam,#
                shape_gnorm        = 7)#
save.image(file.path(output_prefix, 'setup.RData'))#
#
sampling_command <- paste('./lvip_glm',#
                          paste0('data file=', file.path(output_prefix, 'data.json')),#
                          #paste0('init=', file.path(output_prefix, 'inits.json')),#
                          'init=0.1',#
                          'output',#
                          paste0('file=', file.path(output_prefix, 'samples_sampling.csv')),#
                          paste0('refresh=', 1),#
                          'method=sample algorithm=hmc',#
                          'stepsize=0.1',#
                          'engine=nuts',#
                          'max_depth=10',#
                          'adapt t0=10',#
                          'delta=0.8',#
                          'kappa=0.75',#
                          #'init_buffer=10',#
                          #'window=2',#
                          'term_buffer=50',#
                          'num_warmup=1000',#
                          'num_samples=1000',#
                          ('opencl platform=0 device=0')[opencl],#
                          sep=' ')#
#
cmdstanr::write_stan_json(standat, file.path(output_prefix, 'data.json'))#
#
setwd(cmdstanr::cmdstan_path())#
system(paste0(c('make ', 'make STAN_OPENCL=true ')[opencl+1], 'STANCFLAGS="--include-paths=', model_dir, '" ', file.path(model_dir, 'lvip_glm')))#
#
setwd(model_dir)#
print(sampling_command)#
print(date())#
system(sampling_command)#
#
stan.fit <- cmdstanr::read_cmdstan_csv(file.path(output_prefix, 'samples_sampling.csv'),#
                                       format = 'draws_array')#
#
save.image(file.path(output_prefix, 'results.RData'))#
#
monteCarloP <- function(x, pn='p') {#
  if(pn == 'n') {#
    res <- (1 + sum(x >= 0, na.rm=TRUE)) / (1 + length(x))#
  } else if(pn == 'p') {#
    res <- (1 + sum(x <= 0, na.rm=TRUE)) / (1 + length(x))#
  }#
} # https://arxiv.org/pdf/1603.05766.pdf#
#
stan.fit.draws <- stan.fit$post_warmup_draws#
#
time <- stan.fit.draws[,,grep('^time\\[.*',dimnames(stan.fit.draws)[[3]]), drop=FALSE]#
time <- apply(time,3,median)#
#
finalMicrobeTree_time <- finalMicrobeTree#
finalMicrobeTree_time$edge.length <- rev(time[sa[,2]])
hi <- read.table('~/Dropbox/species.tsv',sep='\t')
head(hi)
hi <- read.table('~/Dropbox/species.tsv',sep='\t',header=T)
head(hi)
hi <- read.table('~/Dropbox/Personal_Lab_Stuff/usf/students/demo1_mapped_uniquehits_sorted.stats.txt',sep='\t')
head(hi)
hi <- read.table('~/Dropbox/Personal_Lab_Stuff/usf/students/demo1_mapped_uniquehits_sorted.stats.txt',sep='\t',row.names=0)
hi <- read.table('~/Dropbox/Personal_Lab_Stuff/usf/students/demo1_mapped_uniquehits_sorted.stats.txt',sep='\t',row.names=1)
head(hi)
hist(hi[,1])
hist(log(hi[,1]))
hist(log(hi[,2]))
hist(log(hi[,2] / hi[,1]))
hist(hi[,2] / hi[,1])
hist(log(hi[,2] / hi[,1]))
dim(hi)
dim(hi[hi[,3]>1])
dim(hi[hi[,3]>1,])
dim(hi[hi[,2]>1,])
dim(hi[hi[,2]>2,])
dim(hi[hi[,2]>3,])
dim(hi[hi[,2]>100,])
hi <- read.table('~/Dropbox/Personal_Lab_Stuff/usf/students/taxonomy_names_genes.tsv', header=T)
hi <- read.table('~/Dropbox/Personal_Lab_Stuff/usf/students/taxonomy_names_genes.tsv', header=T, sep='\t')
hi <- read.table('~/Dropbox/Personal_Lab_Stuff/usf/students/taxonomy_names_genes.tsv', sep='\t')
hi <- read.table('~/Dropbox/Personal_Lab_Stuff/usf/students/taxonomy_names_genes.tsv', sep='\t', fill=T)
head(hi)
## get user-edited environmental variables output_prefix, phy_fp, counts_fp, and model_matrix_fp#
model_dir <- getwd()#
source(file.path(model_dir, 'lvip_glm.env'))#
###
#
## set up output directory#
dir.create(output_prefix)#
outfile <- file(file.path(output_prefix, 'runlog.log'), open = 'wt')#
sink(outfile, type = 'output', split = TRUE)#
###
#
counts <- as.matrix(read.table(counts_fp, sep='\t'))#
counts <- counts[,colSums(counts) > 0]#
modelMat <- read.table(model_matrix_fp, sep='\t')#
factorNames <- as.character(modelMat[1,])#
modelMat <- modelMat[-1,]#
idx <- sapply(factorNames, function(x) which(x == unique(factorNames)))#
#
library(ape)#
microbeTree <- phytools::midpoint.root(read.tree(phy_fp))#
finalMicrobeTree <- reorder(drop.tip(microbeTree, microbeTree$tip.label[!microbeTree$tip.label %in% colnames(counts)]), 'pruningwise')#
finalMicrobeTree$edge.length <- finalMicrobeTree$edge.length / mean(phytools::nodeHeights(finalMicrobeTree)[finalMicrobeTree$edge[,2] <= length(finalMicrobeTree$tip.label),2])#
#
counts <- counts[,finalMicrobeTree$tip.label]#
#
## generate some summary numbers regarding microbes#
microbeTips <- colnames(counts)#
NT <- length(microbeTips)#
NI <- finalMicrobeTree$Nnode#
NN <- NI + NT#
sa <- rbind(finalMicrobeTree$edge,c(0,NT+1))[NN:1,]#
divergence <- finalMicrobeTree$edge.length[order(finalMicrobeTree$edge[,2])]#
#
###
NS <- nrow(modelMat)#
NSB <- length(unique(factorNames))#
NB_s <- ncol(modelMat)#
###
#
relabund <- diag(1/rowSums(counts)) %*% counts#
inv_log_max_contam <- 1 / log(max(apply(relabund, 2, function(x) max(x[x>0]) / min(x[x>0]))))#
standat <- list(NS                 = NS,#
                NI                 = NI,#
                NT                 = NT,#
                NB_s               = NB_s,#
                NSB                = NSB,#
                idx                = idx,#
                count              = t(counts),#
                divergence         = divergence,#
                self               = sa[,2],#
                ancestor           = sa[,1],#
                X_s                = modelMat,#
                inv_log_max_contam = inv_log_max_contam,#
                shape_gnorm        = 7)#
save.image(file.path(output_prefix, 'setup.RData'))#
#
sampling_command <- paste('./lvip_glm_centered_2',#
                          paste0('data file=', file.path(output_prefix, 'data.json')),#
                          #paste0('init=', file.path(output_prefix, 'inits.json')),#
                          'init=1',#
                          'output',#
                          paste0('file=', file.path(output_prefix, 'samples_sampling.csv')),#
                          paste0('refresh=', 1),#
                          'method=sample algorithm=hmc',#
                          'stepsize=0.1',#
                          'engine=nuts',#
                          'max_depth=10',#
                          'adapt t0=10',#
                          'delta=0.8',#
                          'kappa=0.75',#
                          #'init_buffer=10',#
                          #'window=2',#
                          'term_buffer=50',#
                          'num_warmup=2000',#
                          'num_samples=2000',#
                          ('opencl platform=0 device=0')[opencl],#
                          sep=' ')#
#
cmdstanr::write_stan_json(standat, file.path(output_prefix, 'data.json'))#
#
setwd(cmdstanr::cmdstan_path())#
system(paste0(c('make ', 'make STAN_OPENCL=true ')[opencl+1], 'STANCFLAGS="--include-paths=', model_dir, '" ', file.path(model_dir, 'lvip_glm_centered_2')))#
#
setwd(model_dir)#
print(sampling_command)#
print(date())#
system(sampling_command)#
#
stan.fit <- cmdstanr::read_cmdstan_csv(file.path(output_prefix, 'samples_sampling.csv'),#
                                       format = 'draws_array')#
#
save.image(file.path(output_prefix, 'results.RData'))
setwd('~/scripts/analysis_templates/microbiomes/lvip_glm')
## get user-edited environmental variables output_prefix, phy_fp, counts_fp, and model_matrix_fp#
model_dir <- getwd()#
source(file.path(model_dir, 'lvip_glm.env'))
counts <- as.matrix(read.table(counts_fp, sep='\t'))#
counts <- counts[,colSums(counts) > 0]#
modelMat <- read.table(model_matrix_fp, sep='\t')#
factorNames <- as.character(modelMat[1,])#
modelMat <- modelMat[-1,]#
idx <- sapply(factorNames, function(x) which(x == unique(factorNames)))#
#
library(ape)#
microbeTree <- phytools::midpoint.root(read.tree(phy_fp))#
finalMicrobeTree <- reorder(drop.tip(microbeTree, microbeTree$tip.label[!microbeTree$tip.label %in% colnames(counts)]), 'pruningwise')#
finalMicrobeTree$edge.length <- finalMicrobeTree$edge.length / mean(phytools::nodeHeights(finalMicrobeTree)[finalMicrobeTree$edge[,2] <= length(finalMicrobeTree$tip.label),2])#
#
counts <- counts[,finalMicrobeTree$tip.label]#
#
## generate some summary numbers regarding microbes#
microbeTips <- colnames(counts)#
NT <- length(microbeTips)#
NI <- finalMicrobeTree$Nnode#
NN <- NI + NT#
sa <- rbind(finalMicrobeTree$edge,c(0,NT+1))[NN:1,]#
divergence <- finalMicrobeTree$edge.length[order(finalMicrobeTree$edge[,2])]#
#
###
NS <- nrow(modelMat)#
NSB <- length(unique(factorNames))#
NB_s <- ncol(modelMat)
stan.fit <- cmdstanr::read_cmdstan_csv(file.path(output_prefix, 'samples_sampling.csv'),#
                                       format = 'draws_array')
stan.fit$post_warmup_sampler_diagnostics[,1,]
stan.fit$post_warmup_sampler_diagnostics[,1,,drop=T]
monteCarloP <- function(x, pn='p') {#
  if(pn == 'n') {#
    res <- (1 + sum(x >= 0, na.rm=TRUE)) / (1 + length(x))#
  } else if(pn == 'p') {#
    res <- (1 + sum(x <= 0, na.rm=TRUE)) / (1 + length(x))#
  }#
} # https://arxiv.org/pdf/1603.05766.pdf#
#
stan.fit.draws <- stan.fit$post_warmup_draws#
#
time <- stan.fit.draws[,,grep('^time\\[.*',dimnames(stan.fit.draws)[[3]]), drop=FALSE]#
time <- apply(time,3,median)#
#
finalMicrobeTree_time <- finalMicrobeTree#
finalMicrobeTree_time$edge.length <- rev(time[sa[,2]])
plot(finalMicrobeTree_time,cex=0.``)
plot(finalMicrobeTree_time,cex=0.1)
coda:::effectiveSize(time)
time <- stan.fit.draws[,,grep('^time\\[.*',dimnames(stan.fit.draws)[[3]]), drop=FALSE]
coda:::effectiveSize(time)
coda:::effectiveSize(time[,1,,drop=T])
coda:::effectiveSize(time[,1,1:10,drop=T])
coda:::effectiveSize(time[,1,100:200,drop=T])
sd_prevalence <- stan.fit.draws[,,grep('^sd_prevalence\\[.*',dimnames(stan.fit.draws)[[3]]), drop=FALSE]
coda:::effectiveSize(sd_prevalence[,1,1:10,drop=T])
coda:::effectiveSize(sd_prevalence[,1,,drop=T])
sd_abundance <- stan.fit.draws[,,grep('^sd_abundance\\[.*',dimnames(stan.fit.draws)[[3]]), drop=FALSE]
coda:::effectiveSize(sd_abundance[,1,,drop=T])

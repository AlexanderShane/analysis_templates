
// Code generated by stanc v2.27.0
#include <stan/model/model_header.hpp>
namespace lvip_glm_model_namespace {

using stan::io::dump;
using stan::model::assign;
using stan::model::index_uni;
using stan::model::index_max;
using stan::model::index_min;
using stan::model::index_min_max;
using stan::model::index_multi;
using stan::model::index_omni;
using stan::model::model_base_crtp;
using stan::model::rvalue;
using namespace stan::math;


stan::math::profile_map profiles__;
static constexpr std::array<const char*, 270> locations_array__ = 
{" (found before start of program)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 32, column 4 to column 43)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 33, column 4 to column 31)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 34, column 4 to column 42)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 35, column 4 to column 41)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 36, column 4 to column 39)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 37, column 4 to column 38)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 38, column 4 to column 42)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 39, column 4 to column 41)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 40, column 4 to column 34)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 41, column 4 to column 37)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 42, column 4 to column 36)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 43, column 4 to column 37)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 44, column 4 to column 36)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 45, column 4 to column 45)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 46, column 4 to column 39)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 49, column 4 to column 29)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 50, column 4 to column 20)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 51, column 4 to column 25)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 52, column 4 to column 24)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 53, column 4 to column 66)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 54, column 4 to column 86)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 55, column 4 to column 83)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 56, column 4 to column 92)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 57, column 4 to column 89)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 58, column 4 to column 61)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 59, column 4 to column 59)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 60, column 4 to column 36)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 61, column 4 to column 35)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 62, column 4 to column 31)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 63, column 4 to column 22)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 65, column 8 to column 18)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 74, column 16 to column 43)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 75, column 16 to column 59)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 72, column 19 to line 76, column 13)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 69, column 16 to column 82)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 70, column 16 to column 84)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 71, column 16 to column 23)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 67, column 29 to line 72, column 13)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 67, column 12 to line 76, column 13)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 66, column 23 to line 77, column 9)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 66, column 8 to line 77, column 9)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 64, column 4 to line 78, column 5)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 79, column 4 to column 27)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 80, column 4 to column 25)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 81, column 4 to column 100)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 82, column 4 to column 50)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 84, column 15 to column 18)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 84, column 8 to column 74)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 85, column 15 to column 18)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 85, column 8 to column 73)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 86, column 8 to line 89, column 165)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 90, column 8 to line 92, column 161)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 83, column 19 to line 93, column 5)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 83, column 4 to line 93, column 5)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 97, column 11 to column 13)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 97, column 14 to column 16)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 97, column 4 to column 53)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 98, column 11 to column 13)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 98, column 14 to column 16)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 98, column 4 to column 61)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 99, column 11 to column 13)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 99, column 14 to column 16)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 99, column 4 to line 103, column 23)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 105, column 4 to column 55)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 106, column 4 to column 66)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 107, column 4 to column 65)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 108, column 4 to column 59)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 109, column 4 to column 58)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 110, column 4 to column 91)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 111, column 4 to column 66)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 112, column 4 to column 65)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 113, column 4 to column 107)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 114, column 4 to column 60)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 116, column 4 to column 113)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 119, column 12 to line 128, column 73)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 118, column 23 to line 129, column 9)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 118, column 8 to line 129, column 9)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 117, column 19 to line 130, column 5)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 117, column 4 to line 130, column 5)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 131, column 4 to line 132, column 101)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 3, column 4 to column 20)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 4, column 4 to column 20)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 5, column 20 to column 27)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 5, column 4 to column 40)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 6, column 10 to column 17)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 6, column 4 to column 28)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 7, column 10 to column 17)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 7, column 4 to column 32)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 8, column 4 to column 11)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 9, column 4 to column 13)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 10, column 4 to column 12)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 11, column 10 to column 14)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 11, column 4 to column 24)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 12, column 11 to column 13)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 12, column 14 to column 18)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 12, column 4 to column 24)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 13, column 10 to column 12)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 13, column 13 to column 15)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 13, column 4 to column 27)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 14, column 4 to column 28)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 15, column 4 to column 30)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 19, column 4 to column 21)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 20, column 10 to column 12)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 20, column 4 to column 25)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 21, column 10 to column 12)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 21, column 4 to column 29)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 22, column 10 to column 12)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 22, column 4 to column 26)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 24, column 8 to column 33)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 25, column 8 to column 41)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 27, column 12 to column 35)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 26, column 26 to line 28, column 9)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 26, column 8 to line 28, column 9)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 23, column 18 to line 29, column 5)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 23, column 4 to line 29, column 5)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 32, column 28 to column 32)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 36, column 12 to column 17)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 37, column 12 to column 17)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 38, column 20 to column 23)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 39, column 20 to column 23)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 40, column 11 to column 15)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 41, column 11 to column 15)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 41, column 16 to column 18)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 42, column 11 to column 15)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 42, column 16 to column 18)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 43, column 11 to column 13)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 43, column 14 to column 16)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 44, column 11 to column 13)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 49, column 11 to column 13)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 50, column 11 to column 13)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 51, column 11 to column 13)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 52, column 11 to column 13)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 54, column 11 to column 16)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 55, column 11 to column 16)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 56, column 11 to column 14)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 57, column 11 to column 14)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 58, column 11 to column 14)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 59, column 11 to column 14)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 60, column 11 to column 15)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 60, column 16 to column 18)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 61, column 11 to column 15)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 61, column 16 to column 18)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 3, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 2, column 77, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 6, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 5, column 58, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 9, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 8, column 58, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 12, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 13, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 14, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 19, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 11, column 79, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 25, column 10, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 23, column 10, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 22, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 21, column 26, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 28, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 29, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 30, column 15, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 30, column 19, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 30, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 31, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 32, column 15, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 32, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 33, column 15, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 33, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 34, column 15, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 34, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 35, column 15, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 35, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 38, column 12, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 41, column 16, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 40, column 25, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 40, column 14, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 39, column 32, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 39, column 12, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 37, column 28, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 37, column 10, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 36, column 26, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 36, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 50, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 52, column 10, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 51, column 26, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 51, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 54, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 27, column 86, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 57, column 15, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 57, column 17, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 57, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 58, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 60, column 12, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 62, column 16, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 63, column 16, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 64, column 16, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 61, column 30, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 61, column 12, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 59, column 26, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 59, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 67, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 68, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 56, column 46, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 71, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 72, column 15, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 72, column 17, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 72, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 74, column 12, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 76, column 16, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 75, column 31, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 75, column 12, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 73, column 27, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 73, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 79, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 80, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 70, column 64, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 83, column 26, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 83, column 15, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 83, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 84, column 28, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 84, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 85, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 82, column 39, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 88, column 15, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 88, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 89, column 46, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 89, column 28, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 89, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 90, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 87, column 35, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 93, column 15, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 93, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 94, column 15, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 94, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 95, column 15, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 95, column 25, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 95, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 97, column 12, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 96, column 30, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 96, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 99, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 92, column 69, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 102, column 15, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 102, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 103, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 105, column 12, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 104, column 28, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 104, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 107, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 101, column 48, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 110, column 15, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 110, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 112, column 12, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 111, column 28, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 111, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 114, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 109, column 52, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 117, column 15, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 117, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 119, column 12, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 118, column 28, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 118, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 121, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 116, column 52, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 124, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 123, column 70, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 130, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 129, column 78, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 137, column 8, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)",
 " (in '/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/functions.stan', line 136, column 68, included from\n'/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm/lvip_glm.stan', line 1, column 0)"};


template <bool propto__, typename T0__, typename T1__, typename T2__,
typename T3__>
stan::promote_args_t<stan::value_type_t<T0__>, T1__,
stan::value_type_t<T2__>,
T3__>
generalized_normal_lpdf(const T0__& y_arg__, const T1__& mu,
                        const T2__& alpha_arg__, const T3__& beta,
                        std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>,
          T1__,
          stan::value_type_t<T2__>,
          T3__>;
  int current_statement__ = 0; 
  const auto& y = to_ref(y_arg__);
  const auto& alpha = to_ref(alpha_arg__);
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 143;
    return sum(
             subtract(
               subtract(
                 subtract((stan::math::log(beta) - stan::math::log(2)),
                   stan::math::log(alpha)), stan::math::lgamma(inv(beta))),
               stan::math::exp(
                 multiply(beta,
                   stan::math::log(
                     elt_divide(stan::math::fabs(subtract(y, mu)), alpha))))));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct generalized_normal_lpdf_functor__ {
template <bool propto__, typename T0__, typename T1__, typename T2__,
typename T3__>
stan::promote_args_t<stan::value_type_t<T0__>, T1__,
stan::value_type_t<T2__>,
T3__>
operator()(const T0__& y, const T1__& mu, const T2__& alpha,
           const T3__& beta, std::ostream* pstream__)  const 
{
return generalized_normal_lpdf<propto__>(y, mu, alpha, beta, pstream__);
}
};

template <bool propto__, typename T0__, typename T1__>
stan::promote_args_t<stan::value_type_t<T0__>,
T1__>
generalized_std_normal_lpdf(const T0__& y_arg__, const T1__& beta,
                            std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>,
          T1__>;
  int current_statement__ = 0; 
  const auto& y = to_ref(y_arg__);
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 145;
    return sum(
             subtract(
               ((stan::math::log(beta) - stan::math::log(2)) -
                 stan::math::lgamma(inv(beta))),
               pow(stan::math::fabs(y), beta)));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct generalized_std_normal_lpdf_functor__ {
template <bool propto__, typename T0__, typename T1__>
stan::promote_args_t<stan::value_type_t<T0__>,
T1__>
operator()(const T0__& y, const T1__& beta, std::ostream* pstream__)  const 
{
return generalized_std_normal_lpdf<propto__>(y, beta, pstream__);
}
};

template <bool propto__, typename T0__, typename T1__>
stan::promote_args_t<T0__,
T1__>
generalized_std_normal_1_lpdf(const T0__& y, const T1__& beta,
                              std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T1__>;
  int current_statement__ = 0; 
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 147;
    return (((stan::math::log(beta) - stan::math::log(2)) -
              stan::math::lgamma(inv(beta))) -
             pow(stan::math::fabs(y), beta));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct generalized_std_normal_1_lpdf_functor__ {
template <bool propto__, typename T0__, typename T1__>
stan::promote_args_t<T0__,
T1__>
operator()(const T0__& y, const T1__& beta, std::ostream* pstream__)  const 
{
return generalized_std_normal_1_lpdf<propto__>(y, beta, pstream__);
}
};

template <bool propto__, typename T0__, typename T1__, typename T2__,
typename T3__>
stan::promote_args_t<stan::value_type_t<T0__>, T1__,
stan::value_type_t<T2__>,
stan::value_type_t<T3__>>
multi_student_t_cholesky_lpdf(const T0__& y_arg__, const T1__& nu,
                              const T2__& mu_arg__, const T3__& L_arg__,
                              std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>,
          T1__,
          stan::value_type_t<T2__>,
          stan::value_type_t<T3__>>;
  int current_statement__ = 0; 
  const auto& y = to_ref(y_arg__);
  const auto& mu = to_ref(mu_arg__);
  const auto& L = to_ref(L_arg__);
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    int N;
    N = std::numeric_limits<int>::min();
    
    current_statement__ = 149;
    N = cols(y);
    int K;
    K = std::numeric_limits<int>::min();
    
    current_statement__ = 150;
    K = cols(L);
    local_scalar_t__ lp;
    lp = DUMMY_VAR__;
    
    current_statement__ = 151;
    lp = (N *
           (((((-0.5 * K) * stan::math::log(nu)) +
               stan::math::lgamma((0.5 * (nu + K)))) -
              stan::math::lgamma((0.5 * nu))) -
             sum(stan::math::log(diagonal(L)))));
    current_statement__ = 152;
    return (lp -
             ((0.5 * (nu + K)) *
               sum(
                 stan::math::log1p(
                   divide(columns_dot_self(multiply(L, subtract(y, mu))), nu)))));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct multi_student_t_cholesky_lpdf_functor__ {
template <bool propto__, typename T0__, typename T1__, typename T2__,
typename T3__>
stan::promote_args_t<stan::value_type_t<T0__>, T1__,
stan::value_type_t<T2__>,
stan::value_type_t<T3__>>
operator()(const T0__& y, const T1__& nu, const T2__& mu, const T3__& L,
           std::ostream* pstream__)  const 
{
return multi_student_t_cholesky_lpdf<propto__>(y, nu, mu, L, pstream__);
}
};

double
ff(const int& k, const int& j, std::ostream* pstream__) {
  using local_scalar_t__ = double;
  int current_statement__ = 0; 
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 156;
    if (j) {
      current_statement__ = 155;
      return falling_factorial(k, j);
    } else {
      current_statement__ = 154;
      return 1;
    }
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct ff_functor__ {
double
operator()(const int& k, const int& j, std::ostream* pstream__)  const 
{
return ff(k, j, pstream__);
}
};

template <typename T0__, typename T2__, typename T3__, typename T4__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>, T2__,
stan::value_type_t<T3__>,
stan::value_type_t<T4__>>, -1, 1>
circular_matern(const T0__& d_arg__, const int& n, const T2__& alpha,
                const T3__& ffKJ_arg__, const T4__& chooseRJ_arg__,
                std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>,
          T2__,
          stan::value_type_t<T3__>,
          stan::value_type_t<T4__>>;
  int current_statement__ = 0; 
  const auto& d = to_ref(d_arg__);
  const auto& ffKJ = to_ref(ffKJ_arg__);
  const auto& chooseRJ = to_ref(chooseRJ_arg__);
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    local_scalar_t__ ap;
    ap = DUMMY_VAR__;
    
    current_statement__ = 158;
    ap = (alpha * stan::math::pi());
    Eigen::Matrix<local_scalar_t__, 1, -1> csap;
    csap = Eigen::Matrix<local_scalar_t__, 1, -1>(2);
    stan::math::fill(csap, DUMMY_VAR__);
    
    current_statement__ = 159;
    assign(csap, (Eigen::Matrix<local_scalar_t__,1,-1>(2) <<
      stan::math::cosh(ap), stan::math::sinh(ap)).finished(),
      "assigning variable csap");
    current_statement__ = 160;
    validate_non_negative_index("H", "n - 1", (n - 1));
    current_statement__ = 161;
    validate_non_negative_index("H", "n", n);
    Eigen::Matrix<local_scalar_t__, -1, -1> H;
    H = Eigen::Matrix<local_scalar_t__, -1, -1>((n - 1), n);
    stan::math::fill(H, DUMMY_VAR__);
    
    local_scalar_t__ annm1;
    annm1 = DUMMY_VAR__;
    
    current_statement__ = 163;
    annm1 = inv((pow((-2 * square(alpha)), (n - 1)) * stan::math::tgamma(n)));
    current_statement__ = 164;
    validate_non_negative_index("a", "n", n);
    Eigen::Matrix<local_scalar_t__, -1, 1> a;
    a = Eigen::Matrix<local_scalar_t__, -1, 1>(n);
    stan::math::fill(a, DUMMY_VAR__);
    
    current_statement__ = 166;
    validate_non_negative_index("adp", "rows(d)", rows(d));
    Eigen::Matrix<local_scalar_t__, -1, 1> adp;
    adp = Eigen::Matrix<local_scalar_t__, -1, 1>(rows(d));
    stan::math::fill(adp, DUMMY_VAR__);
    
    current_statement__ = 167;
    assign(adp, multiply(alpha, subtract(d, stan::math::pi())),
      "assigning variable adp");
    current_statement__ = 168;
    validate_non_negative_index("csadp", "rows(d)", rows(d));
    Eigen::Matrix<local_scalar_t__, -1, -1> csadp;
    csadp = Eigen::Matrix<local_scalar_t__, -1, -1>(rows(d), 2);
    stan::math::fill(csadp, DUMMY_VAR__);
    
    current_statement__ = 169;
    assign(csadp, append_col(stan::math::cosh(adp), stan::math::sinh(adp)),
      "assigning variable csadp");
    current_statement__ = 170;
    validate_non_negative_index("cov", "rows(d)", rows(d));
    Eigen::Matrix<local_scalar_t__, -1, 1> cov;
    cov = Eigen::Matrix<local_scalar_t__, -1, 1>(rows(d));
    stan::math::fill(cov, DUMMY_VAR__);
    
    current_statement__ = 171;
    assign(cov, zeros_vector(rows(d)), "assigning variable cov");
    current_statement__ = 181;
    for (int k = 0; k <= (n - 1); ++k) {
      current_statement__ = 179;
      for (int r = 0; r <= (n - 2); ++r) {
        current_statement__ = 172;
        assign(H, 0,
          "assigning variable H", index_uni((r + 1)), index_uni((k + 1)));
        current_statement__ = 177;
        for (int j = 0; j <= ((2 * r) + 1); ++j) {
          current_statement__ = 175;
          if (logical_lte(j, k)) {
            current_statement__ = 173;
            assign(H,
              (rvalue(H, "H", index_uni((r + 1)), index_uni((k + 1))) +
                (((rvalue(chooseRJ, "chooseRJ",
                     index_uni((r + 1)), index_uni((j + 1))) *
                    rvalue(ffKJ, "ffKJ",
                      index_uni((k + 1)), index_uni((j + 1)))) *
                   pow(ap, (k - j))) *
                  rvalue(csap, "csap",
                    index_uni((modulus(((k - j) + 1), 2) + 1))))),
              "assigning variable H", index_uni((r + 1)), index_uni((k + 1)));
          } 
        }
      }
    }
    current_statement__ = 182;
    assign(a,
      append_row(
        multiply(-annm1,
          mdivide_left(
            rvalue(H, "H", index_omni(), index_min_max(1, (n - 1))),
            rvalue(H, "H", index_omni(), index_uni((n - 1))))), annm1),
      "assigning variable a");
    current_statement__ = 185;
    for (int k = 0; k <= (n - 1); ++k) {
      current_statement__ = 183;
      assign(cov,
        add(stan::model::deep_copy(cov),
          elt_multiply(
            multiply(rvalue(a, "a", index_uni((k + 1))), pow(adp, k)),
            rvalue(csadp, "csadp",
              index_omni(), index_uni((modulus(k, 2) + 1))))),
        "assigning variable cov");
    }
    current_statement__ = 186;
    return divide(cov, ((2 * alpha) * rvalue(csap, "csap", index_uni(2))));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct circular_matern_functor__ {
template <typename T0__, typename T2__, typename T3__, typename T4__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>, T2__,
stan::value_type_t<T3__>,
stan::value_type_t<T4__>>, -1, 1>
operator()(const T0__& d, const int& n, const T2__& alpha, const T3__& ffKJ,
           const T4__& chooseRJ, std::ostream* pstream__)  const 
{
return circular_matern(d, n, alpha, ffKJ, chooseRJ, pstream__);
}
};

template <typename T0__, typename T2__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>,
T2__>, -1, -1>
fill_sym(const T0__& lt_arg__, const int& N, const T2__& c,
         std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>,
          T2__>;
  int current_statement__ = 0; 
  const auto& lt = to_ref(lt_arg__);
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 188;
    validate_non_negative_index("s_mat", "N", N);
    current_statement__ = 189;
    validate_non_negative_index("s_mat", "N", N);
    Eigen::Matrix<local_scalar_t__, -1, -1> s_mat;
    s_mat = Eigen::Matrix<local_scalar_t__, -1, -1>(N, N);
    stan::math::fill(s_mat, DUMMY_VAR__);
    
    int iter;
    iter = std::numeric_limits<int>::min();
    
    current_statement__ = 191;
    iter = 1;
    current_statement__ = 199;
    for (int j = 1; j <= (N - 1); ++j) {
      current_statement__ = 192;
      assign(s_mat, c, "assigning variable s_mat", index_uni(j), index_uni(j));
      current_statement__ = 197;
      for (int i = (j + 1); i <= N; ++i) {
        current_statement__ = 193;
        assign(s_mat, rvalue(lt, "lt", index_uni(iter)),
          "assigning variable s_mat", index_uni(i), index_uni(j));
        current_statement__ = 194;
        assign(s_mat, rvalue(lt, "lt", index_uni(iter)),
          "assigning variable s_mat", index_uni(j), index_uni(i));
        current_statement__ = 195;
        iter = (iter + 1);
      }
    }
    current_statement__ = 200;
    assign(s_mat, c, "assigning variable s_mat", index_uni(N), index_uni(N));
    current_statement__ = 201;
    return s_mat;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct fill_sym_functor__ {
template <typename T0__, typename T2__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>,
T2__>, -1, -1>
operator()(const T0__& lt, const int& N, const T2__& c,
           std::ostream* pstream__)  const 
{
return fill_sym(lt, N, c, pstream__);
}
};

template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>, stan::value_type_t<T1__>,
T2__>, -1, -1>
L_cov_exp_quad_ARD(const T0__& x_arg__, const T1__& rho_arg__,
                   const T2__& delta, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>,
          stan::value_type_t<T1__>,
          T2__>;
  int current_statement__ = 0; 
  const auto& x = to_ref(x_arg__);
  const auto& rho = to_ref(rho_arg__);
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    int N;
    N = std::numeric_limits<int>::min();
    
    current_statement__ = 203;
    N = cols(x);
    current_statement__ = 204;
    validate_non_negative_index("cov", "N", N);
    current_statement__ = 205;
    validate_non_negative_index("cov", "N", N);
    Eigen::Matrix<local_scalar_t__, -1, -1> cov;
    cov = Eigen::Matrix<local_scalar_t__, -1, -1>(N, N);
    stan::math::fill(cov, DUMMY_VAR__);
    
    current_statement__ = 212;
    for (int i = 1; i <= (N - 1); ++i) {
      current_statement__ = 207;
      assign(cov, (1 + delta),
        "assigning variable cov", index_uni(i), index_uni(i));
      current_statement__ = 210;
      for (int j = (i + 1); j <= N; ++j) {
        current_statement__ = 208;
        assign(cov,
          stan::math::exp(
            (-0.5 *
              dot_self(
                elt_divide(
                  subtract(rvalue(x, "x", index_omni(), index_uni(i)),
                    rvalue(x, "x", index_omni(), index_uni(j))), rho)))),
          "assigning variable cov", index_uni(j), index_uni(i));
      }
    }
    current_statement__ = 213;
    assign(cov, (1 + delta),
      "assigning variable cov", index_uni(N), index_uni(N));
    current_statement__ = 214;
    return cholesky_decompose(symmetrize_from_lower_tri(cov));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct L_cov_exp_quad_ARD_functor__ {
template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>, stan::value_type_t<T1__>,
T2__>, -1, -1>
operator()(const T0__& x, const T1__& rho, const T2__& delta,
           std::ostream* pstream__)  const 
{
return L_cov_exp_quad_ARD(x, rho, delta, pstream__);
}
};

template <typename T0__>
std::vector<Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, 1>>
to_vector_array(const T0__& x_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>>;
  int current_statement__ = 0; 
  const auto& x = to_ref(x_arg__);
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 216;
    validate_non_negative_index("y", "cols(x)", cols(x));
    current_statement__ = 217;
    validate_non_negative_index("y", "rows(x)", rows(x));
    std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>> y;
    y = std::vector<Eigen::Matrix<local_scalar_t__, -1, 1>>(cols(x), Eigen::Matrix<local_scalar_t__, -1, 1>(
      rows(x)));
    stan::math::fill(y, DUMMY_VAR__);
    
    current_statement__ = 220;
    for (int j = 1; j <= cols(x); ++j) {
      current_statement__ = 219;
      assign(y, rvalue(x, "x", index_omni(), index_uni(j)),
        "assigning variable y", index_uni(j));
    }
    current_statement__ = 221;
    return y;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct to_vector_array_functor__ {
template <typename T0__>
std::vector<Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, 1>>
operator()(const T0__& x, std::ostream* pstream__)  const 
{
return to_vector_array(x, pstream__);
}
};

template <typename T0__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, -1>
cholesky_like(const T0__& A_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>>;
  int current_statement__ = 0; 
  const auto& A = to_ref(A_arg__);
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 223;
    validate_non_negative_index("lambda", "rows(A)", rows(A));
    Eigen::Matrix<local_scalar_t__, -1, 1> lambda;
    lambda = Eigen::Matrix<local_scalar_t__, -1, 1>(rows(A));
    stan::math::fill(lambda, DUMMY_VAR__);
    
    current_statement__ = 224;
    assign(lambda, eigenvalues_sym(A), "assigning variable lambda");
    current_statement__ = 227;
    for (int i = 1; i <= rows(A); ++i) {
      current_statement__ = 226;
      if (logical_lt(rvalue(lambda, "lambda", index_uni(i)), 0)) {
        current_statement__ = 225;
        assign(lambda, 0, "assigning variable lambda", index_uni(i));
      } 
    }
    current_statement__ = 228;
    return transpose(
             qr_thin_R(
               transpose(
                 diag_post_multiply(eigenvectors_sym(A),
                   stan::math::sqrt(lambda)))));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct cholesky_like_functor__ {
template <typename T0__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, -1>
operator()(const T0__& A, std::ostream* pstream__)  const 
{
return cholesky_like(A, pstream__);
}
};

template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>, stan::value_type_t<T1__>,
stan::value_type_t<T2__>>, -1, -1>
transform_MVN_kumaraswamy(const T0__& mvn_arg__, const T1__& a_arg__,
                          const T2__& b_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>,
          stan::value_type_t<T1__>,
          stan::value_type_t<T2__>>;
  int current_statement__ = 0; 
  const auto& mvn = to_ref(mvn_arg__);
  const auto& a = to_ref(a_arg__);
  const auto& b = to_ref(b_arg__);
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 230;
    validate_non_negative_index("m1", "size(b)", size(b));
    Eigen::Matrix<local_scalar_t__, -1, 1> m1;
    m1 = Eigen::Matrix<local_scalar_t__, -1, 1>(size(b));
    stan::math::fill(m1, DUMMY_VAR__);
    
    current_statement__ = 231;
    assign(m1, elt_multiply(b, beta(add(1, inv(a)), b)),
      "assigning variable m1");
    current_statement__ = 232;
    validate_non_negative_index("m2n", "size(b)", size(b));
    Eigen::Matrix<local_scalar_t__, -1, 1> m2n;
    m2n = Eigen::Matrix<local_scalar_t__, -1, 1>(size(b));
    stan::math::fill(m2n, DUMMY_VAR__);
    
    current_statement__ = 233;
    assign(m2n,
      subtract(elt_multiply(b, beta(add(1, multiply(2.0, inv(a))), b)),
        square(m1)), "assigning variable m2n");
    current_statement__ = 234;
    validate_non_negative_index("k", "rows(mvn)", rows(mvn));
    current_statement__ = 235;
    validate_non_negative_index("k", "cols(mvn)", cols(mvn));
    Eigen::Matrix<local_scalar_t__, -1, -1> k;
    k = Eigen::Matrix<local_scalar_t__, -1, -1>(rows(mvn), cols(mvn));
    stan::math::fill(k, DUMMY_VAR__);
    
    current_statement__ = 239;
    for (int i = 1; i <= rows(mvn); ++i) {
      current_statement__ = 237;
      assign(k,
        divide(
          subtract(
            pow(
              subtract(1,
                pow(
                  subtract(1,
                    Phi(rvalue(mvn, "mvn", index_uni(i), index_omni()))),
                  inv(rvalue(b, "b", index_uni(i))))),
              inv(rvalue(a, "a", index_uni(i)))),
            rvalue(m1, "m1", index_uni(i))),
          stan::math::sqrt(rvalue(m2n, "m2n", index_uni(i)))),
        "assigning variable k", index_uni(i), index_omni());
    }
    current_statement__ = 240;
    return k;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct transform_MVN_kumaraswamy_functor__ {
template <typename T0__, typename T1__, typename T2__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>, stan::value_type_t<T1__>,
stan::value_type_t<T2__>>, -1, -1>
operator()(const T0__& mvn, const T1__& a, const T2__& b,
           std::ostream* pstream__)  const 
{
return transform_MVN_kumaraswamy(mvn, a, b, pstream__);
}
};

template <typename T0__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, 1>
positive_ordered_transform(const T0__& y_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>>;
  int current_statement__ = 0; 
  const auto& y = to_ref(y_arg__);
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 242;
    validate_non_negative_index("x", "size(y)", size(y));
    Eigen::Matrix<local_scalar_t__, -1, 1> x;
    x = Eigen::Matrix<local_scalar_t__, -1, 1>(size(y));
    stan::math::fill(x, DUMMY_VAR__);
    
    current_statement__ = 243;
    assign(x, y, "assigning variable x");
    current_statement__ = 244;
    assign(x, stan::math::exp(rvalue(y, "y", index_uni(1))),
      "assigning variable x", index_uni(1));
    current_statement__ = 247;
    for (int k = 2; k <= size(y); ++k) {
      current_statement__ = 245;
      assign(x,
        (rvalue(x, "x", index_uni((k - 1))) *
          inv_logit(rvalue(y, "y", index_uni(k)))),
        "assigning variable x", index_uni(k));
    }
    current_statement__ = 248;
    return x;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct positive_ordered_transform_functor__ {
template <typename T0__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, 1>
operator()(const T0__& y, std::ostream* pstream__)  const 
{
return positive_ordered_transform(y, pstream__);
}
};

template <typename T0__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, 1>
positive_max_ordered_transform(const T0__& y_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>>;
  int current_statement__ = 0; 
  const auto& y = to_ref(y_arg__);
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 250;
    validate_non_negative_index("x", "size(y)", size(y));
    Eigen::Matrix<local_scalar_t__, -1, 1> x;
    x = Eigen::Matrix<local_scalar_t__, -1, 1>(size(y));
    stan::math::fill(x, DUMMY_VAR__);
    
    current_statement__ = 251;
    assign(x, y, "assigning variable x");
    current_statement__ = 254;
    for (int k = 2; k <= size(y); ++k) {
      current_statement__ = 252;
      assign(x,
        (rvalue(x, "x", index_uni((k - 1))) *
          inv_logit(rvalue(y, "y", index_uni(k)))),
        "assigning variable x", index_uni(k));
    }
    current_statement__ = 255;
    return x;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct positive_max_ordered_transform_functor__ {
template <typename T0__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, 1>
operator()(const T0__& y, std::ostream* pstream__)  const 
{
return positive_max_ordered_transform(y, pstream__);
}
};

template <typename T0__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, 1>
log_positive_ordered_transform(const T0__& y_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>>;
  int current_statement__ = 0; 
  const auto& y = to_ref(y_arg__);
  static constexpr bool propto__ = true;
  (void) propto__;
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 257;
    validate_non_negative_index("x", "size(y)", size(y));
    Eigen::Matrix<local_scalar_t__, -1, 1> x;
    x = Eigen::Matrix<local_scalar_t__, -1, 1>(size(y));
    stan::math::fill(x, DUMMY_VAR__);
    
    current_statement__ = 258;
    assign(x, y, "assigning variable x");
    current_statement__ = 261;
    for (int k = 2; k <= size(y); ++k) {
      current_statement__ = 259;
      assign(x,
        (rvalue(x, "x", index_uni((k - 1))) +
          log_inv_logit(rvalue(y, "y", index_uni(k)))),
        "assigning variable x", index_uni(k));
    }
    current_statement__ = 262;
    return x;
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct log_positive_ordered_transform_functor__ {
template <typename T0__>
Eigen::Matrix<stan::promote_args_t<stan::value_type_t<T0__>>, -1, 1>
operator()(const T0__& y, std::ostream* pstream__)  const 
{
return log_positive_ordered_transform(y, pstream__);
}
};

template <bool propto__, typename T0__, typename T1__, typename T2__,
typename T3__>
stan::promote_args_t<T0__, T1__, T2__,
T3__>
student_t_log_lpdf(const T0__& y, const T1__& nu, const T2__& mu,
                   const T3__& sigma_log, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<T0__, T1__, T2__, T3__>;
  int current_statement__ = 0; 
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 264;
    return (((log_falling_factorial((0.5 * (nu - 1)), 0.5) -
               (0.5 * stan::math::log((stan::math::pi() * nu)))) - sigma_log)
             -
             ((0.5 * (nu + 1)) *
               log1p_exp(
                 ((2 *
                    (stan::math::log(stan::math::fabs((y - mu))) - sigma_log))
                   - stan::math::log(nu)))));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct student_t_log_lpdf_functor__ {
template <bool propto__, typename T0__, typename T1__, typename T2__,
typename T3__>
stan::promote_args_t<T0__, T1__, T2__,
T3__>
operator()(const T0__& y, const T1__& nu, const T2__& mu,
           const T3__& sigma_log, std::ostream* pstream__)  const 
{
return student_t_log_lpdf<propto__>(y, nu, mu, sigma_log, pstream__);
}
};

template <bool propto__, typename T0__, typename T1__, typename T2__,
typename T3__>
stan::promote_args_t<stan::value_type_t<T0__>, T1__,
stan::value_type_t<T2__>,
stan::value_type_t<T3__>>
student_t_log_v_lpdf(const T0__& y_arg__, const T1__& nu,
                     const T2__& mu_arg__, const T3__& sigma_log_arg__,
                     std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>,
          T1__,
          stan::value_type_t<T2__>,
          stan::value_type_t<T3__>>;
  int current_statement__ = 0; 
  const auto& y = to_ref(y_arg__);
  const auto& mu = to_ref(mu_arg__);
  const auto& sigma_log = to_ref(sigma_log_arg__);
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 266;
    return ((size(y) *
              (log_falling_factorial((0.5 * (nu - 1)), 0.5) -
                (0.5 * stan::math::log((stan::math::pi() * nu))))) -
             sum(
               add(sigma_log,
                 multiply((0.5 * (nu + 1)),
                   log1p_exp(
                     subtract(
                       multiply(2,
                         subtract(
                           stan::math::log(stan::math::fabs(subtract(y, mu))),
                           sigma_log)), stan::math::log(nu)))))));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct student_t_log_v_lpdf_functor__ {
template <bool propto__, typename T0__, typename T1__, typename T2__,
typename T3__>
stan::promote_args_t<stan::value_type_t<T0__>, T1__,
stan::value_type_t<T2__>,
stan::value_type_t<T3__>>
operator()(const T0__& y, const T1__& nu, const T2__& mu,
           const T3__& sigma_log, std::ostream* pstream__)  const 
{
return student_t_log_v_lpdf<propto__>(y, nu, mu, sigma_log, pstream__);
}
};

template <bool propto__, typename T0__, typename T1__, typename T2__>
stan::promote_args_t<stan::value_type_t<T0__>, T1__,
stan::value_type_t<T2__>>
student_t_log_v0_lpdf(const T0__& y_arg__, const T1__& nu,
                      const T2__& sigma_log_arg__, std::ostream* pstream__) {
  using local_scalar_t__ = stan::promote_args_t<stan::value_type_t<T0__>,
          T1__,
          stan::value_type_t<T2__>>;
  int current_statement__ = 0; 
  const auto& y = to_ref(y_arg__);
  const auto& sigma_log = to_ref(sigma_log_arg__);
  local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  (void) DUMMY_VAR__;  // suppress unused var warning
  try {
    current_statement__ = 268;
    return ((size(y) *
              (log_falling_factorial((0.5 * (nu - 1)), 0.5) -
                (0.5 * stan::math::log((stan::math::pi() * nu))))) -
             sum(
               add(sigma_log,
                 multiply((0.5 * (nu + 1)),
                   log1p_exp(
                     subtract(
                       multiply(2,
                         subtract(stan::math::log(stan::math::fabs(y)),
                           sigma_log)), stan::math::log(nu)))))));
  } catch (const std::exception& e) {
    stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
  }
  
}

struct student_t_log_v0_lpdf_functor__ {
template <bool propto__, typename T0__, typename T1__, typename T2__>
stan::promote_args_t<stan::value_type_t<T0__>, T1__,
stan::value_type_t<T2__>>
operator()(const T0__& y, const T1__& nu, const T2__& sigma_log,
           std::ostream* pstream__)  const 
{
return student_t_log_v0_lpdf<propto__>(y, nu, sigma_log, pstream__);
}
};

class lvip_glm_model final : public model_base_crtp<lvip_glm_model> {

 private:
  int NT;
  int NI;
  Eigen::Matrix<double, -1, 1> divergence__;
  std::vector<int> self;
  std::vector<int> ancestor;
  int NS;
  int NB_s;
  int NSB;
  std::vector<int> idx;
  Eigen::Matrix<double, -1, -1> X_s__;
  std::vector<std::vector<int>> count;
  double inv_log_max_contam;
  double shape_gnorm;
  int NN;
  std::vector<int> self_i;
  std::vector<int> ancestor_i;
  std::vector<int> self_i2;
  int time_raw_1dim__;
  int var_prop_prevalence_1dim__;
  int var_prop_abundance_1dim__;
  int sd_prevalence_1dim__;
  int sd_abundance_1dim__; 
  Eigen::Map<Eigen::Matrix<double, -1, 1>> divergence{nullptr, 0};
  Eigen::Map<Eigen::Matrix<double, -1, -1>> X_s{nullptr, 0, 0};
 
 public:
  ~lvip_glm_model() { }
  
  inline std::string model_name() const final { return "lvip_glm_model"; }

  inline std::vector<std::string> model_compile_info() const noexcept {
    return std::vector<std::string>{"stanc_version = stanc3 v2.27.0", "stancflags = --include-paths=/Users/Ryan/scripts/analysis_templates/microbiomes/lvip_glm"};
  }
  
  
  lvip_glm_model(stan::io::var_context& context__,
                 unsigned int random_seed__ = 0,
                 std::ostream* pstream__ = nullptr) : model_base_crtp(0) {
    int current_statement__ = 0;
    using local_scalar_t__ = double ;
    boost::ecuyer1988 base_rng__ = 
        stan::services::util::create_rng(random_seed__, 0);
    (void) base_rng__;  // suppress unused var warning
    static constexpr const char* function__ = "lvip_glm_model_namespace::lvip_glm_model";
    (void) function__;  // suppress unused var warning
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      current_statement__ = 81;
      context__.validate_dims("data initialization","NT","int",
           std::vector<size_t>{});
      NT = std::numeric_limits<int>::min();
      
      current_statement__ = 81;
      NT = context__.vals_i("NT")[(1 - 1)];
      current_statement__ = 81;
      check_greater_or_equal(function__, "NT", NT, 2);
      current_statement__ = 82;
      context__.validate_dims("data initialization","NI","int",
           std::vector<size_t>{});
      NI = std::numeric_limits<int>::min();
      
      current_statement__ = 82;
      NI = context__.vals_i("NI")[(1 - 1)];
      current_statement__ = 82;
      check_greater_or_equal(function__, "NI", NI, 1);
      current_statement__ = 83;
      validate_non_negative_index("divergence", "NT + NI - 1",
                                  ((NT + NI) - 1));
      current_statement__ = 84;
      context__.validate_dims("data initialization","divergence","double",
           std::vector<size_t>{static_cast<size_t>(((NT + NI) - 1))});
      divergence__ = Eigen::Matrix<double, -1, 1>(((NT + NI) - 1));
      new (&divergence) Eigen::Map<Eigen::Matrix<double, -1, 1>>(divergence__.data(), 
        ((NT + NI) - 1));
      
      
      {
        std::vector<local_scalar_t__> divergence_flat__;
        current_statement__ = 84;
        divergence_flat__ = context__.vals_r("divergence");
        current_statement__ = 84;
        pos__ = 1;
        current_statement__ = 84;
        for (int sym1__ = 1; sym1__ <= ((NT + NI) - 1); ++sym1__) {
          current_statement__ = 84;
          assign(divergence, divergence_flat__[(pos__ - 1)],
            "assigning variable divergence", index_uni(sym1__));
          current_statement__ = 84;
          pos__ = (pos__ + 1);
        }
      }
      current_statement__ = 84;
      for (int sym1__ = 1; sym1__ <= ((NT + NI) - 1); ++sym1__) {
        current_statement__ = 84;
        check_greater_or_equal(function__, "divergence[sym1__]",
                               divergence[(sym1__ - 1)], 0);
      }
      current_statement__ = 85;
      validate_non_negative_index("self", "NT + NI", (NT + NI));
      current_statement__ = 86;
      context__.validate_dims("data initialization","self","int",
           std::vector<size_t>{static_cast<size_t>((NT + NI))});
      self = std::vector<int>((NT + NI), std::numeric_limits<int>::min());
      
      current_statement__ = 86;
      self = context__.vals_i("self");
      current_statement__ = 87;
      validate_non_negative_index("ancestor", "NT + NI", (NT + NI));
      current_statement__ = 88;
      context__.validate_dims("data initialization","ancestor","int",
           std::vector<size_t>{static_cast<size_t>((NT + NI))});
      ancestor = std::vector<int>((NT + NI), std::numeric_limits<int>::min());
      
      current_statement__ = 88;
      ancestor = context__.vals_i("ancestor");
      current_statement__ = 89;
      context__.validate_dims("data initialization","NS","int",
           std::vector<size_t>{});
      NS = std::numeric_limits<int>::min();
      
      current_statement__ = 89;
      NS = context__.vals_i("NS")[(1 - 1)];
      current_statement__ = 90;
      context__.validate_dims("data initialization","NB_s","int",
           std::vector<size_t>{});
      NB_s = std::numeric_limits<int>::min();
      
      current_statement__ = 90;
      NB_s = context__.vals_i("NB_s")[(1 - 1)];
      current_statement__ = 91;
      context__.validate_dims("data initialization","NSB","int",
           std::vector<size_t>{});
      NSB = std::numeric_limits<int>::min();
      
      current_statement__ = 91;
      NSB = context__.vals_i("NSB")[(1 - 1)];
      current_statement__ = 92;
      validate_non_negative_index("idx", "NB_s", NB_s);
      current_statement__ = 93;
      context__.validate_dims("data initialization","idx","int",
           std::vector<size_t>{static_cast<size_t>(NB_s)});
      idx = std::vector<int>(NB_s, std::numeric_limits<int>::min());
      
      current_statement__ = 93;
      idx = context__.vals_i("idx");
      current_statement__ = 94;
      validate_non_negative_index("X_s", "NS", NS);
      current_statement__ = 95;
      validate_non_negative_index("X_s", "NB_s", NB_s);
      current_statement__ = 96;
      context__.validate_dims("data initialization","X_s","double",
           std::vector<size_t>{static_cast<size_t>(NS),
            static_cast<size_t>(NB_s)});
      X_s__ = Eigen::Matrix<double, -1, -1>(NS, NB_s);
      new (&X_s) Eigen::Map<Eigen::Matrix<double, -1, -1>>(X_s__.data(), NS, NB_s);
      
      
      {
        std::vector<local_scalar_t__> X_s_flat__;
        current_statement__ = 96;
        X_s_flat__ = context__.vals_r("X_s");
        current_statement__ = 96;
        pos__ = 1;
        current_statement__ = 96;
        for (int sym1__ = 1; sym1__ <= NB_s; ++sym1__) {
          current_statement__ = 96;
          for (int sym2__ = 1; sym2__ <= NS; ++sym2__) {
            current_statement__ = 96;
            assign(X_s, X_s_flat__[(pos__ - 1)],
              "assigning variable X_s", index_uni(sym2__), index_uni(sym1__));
            current_statement__ = 96;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 97;
      validate_non_negative_index("count", "NT", NT);
      current_statement__ = 98;
      validate_non_negative_index("count", "NS", NS);
      current_statement__ = 99;
      context__.validate_dims("data initialization","count","int",
           std::vector<size_t>{static_cast<size_t>(NT),
            static_cast<size_t>(NS)});
      count = std::vector<std::vector<int>>(NT, std::vector<int>(NS, std::numeric_limits<int>::min()));
      
      
      {
        std::vector<int> count_flat__;
        current_statement__ = 99;
        count_flat__ = context__.vals_i("count");
        current_statement__ = 99;
        pos__ = 1;
        current_statement__ = 99;
        for (int sym1__ = 1; sym1__ <= NS; ++sym1__) {
          current_statement__ = 99;
          for (int sym2__ = 1; sym2__ <= NT; ++sym2__) {
            current_statement__ = 99;
            assign(count, count_flat__[(pos__ - 1)],
              "assigning variable count", index_uni(sym2__),
                                            index_uni(sym1__));
            current_statement__ = 99;
            pos__ = (pos__ + 1);
          }
        }
      }
      current_statement__ = 100;
      context__.validate_dims("data initialization","inv_log_max_contam",
          "double", std::vector<size_t>{});
      inv_log_max_contam = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 100;
      inv_log_max_contam = context__.vals_r("inv_log_max_contam")[(1 - 1)];
      current_statement__ = 101;
      context__.validate_dims("data initialization","shape_gnorm","double",
           std::vector<size_t>{});
      shape_gnorm = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 101;
      shape_gnorm = context__.vals_r("shape_gnorm")[(1 - 1)];
      current_statement__ = 101;
      check_greater_or_equal(function__, "shape_gnorm", shape_gnorm, 0);
      current_statement__ = 102;
      NN = std::numeric_limits<int>::min();
      
      current_statement__ = 102;
      NN = (NT + NI);
      current_statement__ = 103;
      validate_non_negative_index("self_i", "NN", NN);
      current_statement__ = 104;
      self_i = std::vector<int>(NN, std::numeric_limits<int>::min());
      
      current_statement__ = 105;
      validate_non_negative_index("ancestor_i", "NN", NN);
      current_statement__ = 106;
      ancestor_i = std::vector<int>(NN, std::numeric_limits<int>::min());
      
      current_statement__ = 107;
      validate_non_negative_index("self_i2", "NI", NI);
      current_statement__ = 108;
      self_i2 = std::vector<int>(NI, std::numeric_limits<int>::min());
      
      current_statement__ = 115;
      for (int m = 1; m <= NN; ++m) {
        current_statement__ = 109;
        assign(self_i, (rvalue(self, "self", index_uni(m)) - NT),
          "assigning variable self_i", index_uni(m));
        current_statement__ = 110;
        assign(ancestor_i, (rvalue(ancestor, "ancestor", index_uni(m)) - NT),
          "assigning variable ancestor_i", index_uni(m));
        current_statement__ = 113;
        if (logical_gt(rvalue(self_i, "self_i", index_uni(m)), 0)) {
          current_statement__ = 111;
          assign(self_i2, m,
            "assigning variable self_i2", index_uni(rvalue(self_i, "self_i",
                                                      index_uni(m))));
        } 
      }
      current_statement__ = 116;
      time_raw_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 116;
      time_raw_1dim__ = (NI - 1);
      current_statement__ = 116;
      validate_non_negative_index("time_raw", "NI - 1", time_raw_1dim__);
      current_statement__ = 117;
      var_prop_prevalence_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 117;
      var_prop_prevalence_1dim__ = (2 * NSB);
      current_statement__ = 117;
      validate_positive_index("var_prop_prevalence", "2 * NSB",
                              var_prop_prevalence_1dim__);
      current_statement__ = 118;
      var_prop_abundance_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 118;
      var_prop_abundance_1dim__ = (NSB + 1);
      current_statement__ = 118;
      validate_positive_index("var_prop_abundance", "NSB + 1",
                              var_prop_abundance_1dim__);
      current_statement__ = 119;
      validate_non_negative_index("sigma_prevalence", "NSB", NSB);
      current_statement__ = 120;
      validate_non_negative_index("sigma_abundance", "NSB", NSB);
      current_statement__ = 121;
      validate_non_negative_index("theta_prevalence", "NB_s", NB_s);
      current_statement__ = 122;
      validate_non_negative_index("delta_prevalence", "NB_s", NB_s);
      current_statement__ = 123;
      validate_non_negative_index("delta_prevalence", "NN", NN);
      current_statement__ = 124;
      validate_non_negative_index("delta_abundance", "NB_s", NB_s);
      current_statement__ = 125;
      validate_non_negative_index("delta_abundance", "NN", NN);
      current_statement__ = 126;
      validate_non_negative_index("abundance_observed", "NS", NS);
      current_statement__ = 127;
      validate_non_negative_index("abundance_observed", "NT", NT);
      current_statement__ = 128;
      validate_non_negative_index("multinomial_nuisance", "NS", NS);
      current_statement__ = 129;
      validate_non_negative_index("time_absolute", "NN", NN);
      current_statement__ = 130;
      validate_non_negative_index("time", "NN", NN);
      current_statement__ = 131;
      validate_non_negative_index("time_sqrt", "NN", NN);
      current_statement__ = 132;
      validate_non_negative_index("time_log", "NN", NN);
      current_statement__ = 133;
      sd_prevalence_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 133;
      sd_prevalence_1dim__ = (2 * NSB);
      current_statement__ = 133;
      validate_non_negative_index("sd_prevalence", "2 * NSB",
                                  sd_prevalence_1dim__);
      current_statement__ = 134;
      sd_abundance_1dim__ = std::numeric_limits<int>::min();
      
      current_statement__ = 134;
      sd_abundance_1dim__ = (NSB + 1);
      current_statement__ = 134;
      validate_non_negative_index("sd_abundance", "NSB + 1",
                                  sd_abundance_1dim__);
      current_statement__ = 135;
      validate_non_negative_index("alpha_prevalence_log", "NSB", NSB);
      current_statement__ = 136;
      validate_non_negative_index("alpha_abundance_log", "NSB", NSB);
      current_statement__ = 137;
      validate_non_negative_index("alpha_prevalence", "NSB", NSB);
      current_statement__ = 138;
      validate_non_negative_index("alpha_abundance", "NSB", NSB);
      current_statement__ = 139;
      validate_non_negative_index("beta_prevalence", "NB_s", NB_s);
      current_statement__ = 140;
      validate_non_negative_index("beta_prevalence", "NN", NN);
      current_statement__ = 141;
      validate_non_negative_index("beta_abundance", "NB_s", NB_s);
      current_statement__ = 142;
      validate_non_negative_index("beta_abundance", "NN", NN);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    num_params_r__ = time_raw_1dim__ + 1 + 1 + 1
       + (var_prop_prevalence_1dim__ - 1) + (var_prop_abundance_1dim__ - 1)
       + NSB + NSB + NB_s + (NB_s * NN) + (NB_s * NN) + (NS * NT) + NS + 
      1 + 1;
    
  }
  
  template <bool propto__, bool jacobian__ , typename VecR, typename VecI, 
  stan::require_vector_like_t<VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline stan::scalar_type_t<VecR> log_prob_impl(VecR& params_r__,
                                                 VecI& params_i__,
                                                 std::ostream* pstream__ = nullptr) const {
    using T__ = stan::scalar_type_t<VecR>;
    using local_scalar_t__ = T__;
    T__ lp__(0.0);
    stan::math::accumulator<T__> lp_accum__;
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    int current_statement__ = 0;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "lvip_glm_model_namespace::log_prob";
    (void) function__;  // suppress unused var warning
    
    try {
      Eigen::Matrix<local_scalar_t__, -1, 1> time_raw;
      time_raw = Eigen::Matrix<local_scalar_t__, -1, 1>(time_raw_1dim__);
      stan::math::fill(time_raw, DUMMY_VAR__);
      
      current_statement__ = 1;
      time_raw = in__.template read_constrain_lub<Eigen::Matrix<local_scalar_t__, -1, 1>, jacobian__>(
                   0, 1, lp__, time_raw_1dim__);
      local_scalar_t__ seq_div_rate;
      seq_div_rate = DUMMY_VAR__;
      
      current_statement__ = 2;
      seq_div_rate = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(
                       0, lp__);
      local_scalar_t__ global_scale_prevalence;
      global_scale_prevalence = DUMMY_VAR__;
      
      current_statement__ = 3;
      global_scale_prevalence = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(
                                  0, lp__);
      local_scalar_t__ global_scale_abundance;
      global_scale_abundance = DUMMY_VAR__;
      
      current_statement__ = 4;
      global_scale_abundance = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(
                                 0, lp__);
      Eigen::Matrix<local_scalar_t__, -1, 1> var_prop_prevalence;
      var_prop_prevalence = Eigen::Matrix<local_scalar_t__, -1, 1>(var_prop_prevalence_1dim__);
      stan::math::fill(var_prop_prevalence, DUMMY_VAR__);
      
      current_statement__ = 5;
      var_prop_prevalence = in__.template read_constrain_simplex<Eigen::Matrix<local_scalar_t__, -1, 1>, jacobian__>(
                              lp__, var_prop_prevalence_1dim__);
      Eigen::Matrix<local_scalar_t__, -1, 1> var_prop_abundance;
      var_prop_abundance = Eigen::Matrix<local_scalar_t__, -1, 1>(var_prop_abundance_1dim__);
      stan::math::fill(var_prop_abundance, DUMMY_VAR__);
      
      current_statement__ = 6;
      var_prop_abundance = in__.template read_constrain_simplex<Eigen::Matrix<local_scalar_t__, -1, 1>, jacobian__>(
                             lp__, var_prop_abundance_1dim__);
      Eigen::Matrix<local_scalar_t__, -1, 1> sigma_prevalence;
      sigma_prevalence = Eigen::Matrix<local_scalar_t__, -1, 1>(NSB);
      stan::math::fill(sigma_prevalence, DUMMY_VAR__);
      
      current_statement__ = 7;
      sigma_prevalence = in__.template read_constrain_lb<Eigen::Matrix<local_scalar_t__, -1, 1>, jacobian__>(
                           0, lp__, NSB);
      Eigen::Matrix<local_scalar_t__, -1, 1> sigma_abundance;
      sigma_abundance = Eigen::Matrix<local_scalar_t__, -1, 1>(NSB);
      stan::math::fill(sigma_abundance, DUMMY_VAR__);
      
      current_statement__ = 8;
      sigma_abundance = in__.template read_constrain_lb<Eigen::Matrix<local_scalar_t__, -1, 1>, jacobian__>(
                          0, lp__, NSB);
      Eigen::Matrix<local_scalar_t__, -1, 1> theta_prevalence;
      theta_prevalence = Eigen::Matrix<local_scalar_t__, -1, 1>(NB_s);
      stan::math::fill(theta_prevalence, DUMMY_VAR__);
      
      current_statement__ = 9;
      theta_prevalence = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                           NB_s);
      Eigen::Matrix<local_scalar_t__, -1, -1> delta_prevalence;
      delta_prevalence = Eigen::Matrix<local_scalar_t__, -1, -1>(NB_s, NN);
      stan::math::fill(delta_prevalence, DUMMY_VAR__);
      
      current_statement__ = 10;
      delta_prevalence = in__.template read<Eigen::Matrix<local_scalar_t__, -1, -1>>(
                           NB_s, NN);
      Eigen::Matrix<local_scalar_t__, -1, -1> delta_abundance;
      delta_abundance = Eigen::Matrix<local_scalar_t__, -1, -1>(NB_s, NN);
      stan::math::fill(delta_abundance, DUMMY_VAR__);
      
      current_statement__ = 11;
      delta_abundance = in__.template read<Eigen::Matrix<local_scalar_t__, -1, -1>>(
                          NB_s, NN);
      Eigen::Matrix<local_scalar_t__, -1, -1> abundance_observed;
      abundance_observed = Eigen::Matrix<local_scalar_t__, -1, -1>(NS, NT);
      stan::math::fill(abundance_observed, DUMMY_VAR__);
      
      current_statement__ = 12;
      abundance_observed = in__.template read<Eigen::Matrix<local_scalar_t__, -1, -1>>(
                             NS, NT);
      Eigen::Matrix<local_scalar_t__, -1, 1> multinomial_nuisance;
      multinomial_nuisance = Eigen::Matrix<local_scalar_t__, -1, 1>(NS);
      stan::math::fill(multinomial_nuisance, DUMMY_VAR__);
      
      current_statement__ = 13;
      multinomial_nuisance = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                               NS);
      local_scalar_t__ inv_log_less_contamination;
      inv_log_less_contamination = DUMMY_VAR__;
      
      current_statement__ = 14;
      inv_log_less_contamination = in__.template read_constrain_ub<local_scalar_t__, jacobian__>(
                                     0, lp__);
      local_scalar_t__ contaminant_overdisp;
      contaminant_overdisp = DUMMY_VAR__;
      
      current_statement__ = 15;
      contaminant_overdisp = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(
                               0, lp__);
      Eigen::Matrix<local_scalar_t__, -1, 1> time_absolute;
      time_absolute = Eigen::Matrix<local_scalar_t__, -1, 1>(NN);
      stan::math::fill(time_absolute, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, 1> time;
      time = Eigen::Matrix<local_scalar_t__, -1, 1>(NN);
      stan::math::fill(time, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, 1> time_sqrt;
      time_sqrt = Eigen::Matrix<local_scalar_t__, -1, 1>(NN);
      stan::math::fill(time_sqrt, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, 1> time_log;
      time_log = Eigen::Matrix<local_scalar_t__, -1, 1>(NN);
      stan::math::fill(time_log, DUMMY_VAR__);
      
      local_scalar_t__ log_less_contamination;
      log_less_contamination = DUMMY_VAR__;
      
      current_statement__ = 20;
      log_less_contamination = inv(inv_log_less_contamination);
      Eigen::Matrix<local_scalar_t__, -1, 1> sd_prevalence;
      sd_prevalence = Eigen::Matrix<local_scalar_t__, -1, 1>(sd_prevalence_1dim__);
      stan::math::fill(sd_prevalence, DUMMY_VAR__);
      
      current_statement__ = 21;
      assign(sd_prevalence,
        multiply(stan::math::sqrt(var_prop_prevalence),
          global_scale_prevalence), "assigning variable sd_prevalence");
      Eigen::Matrix<local_scalar_t__, -1, 1> sd_abundance;
      sd_abundance = Eigen::Matrix<local_scalar_t__, -1, 1>(sd_abundance_1dim__);
      stan::math::fill(sd_abundance, DUMMY_VAR__);
      
      current_statement__ = 22;
      assign(sd_abundance,
        multiply(stan::math::sqrt(var_prop_abundance),
          global_scale_abundance), "assigning variable sd_abundance");
      Eigen::Matrix<local_scalar_t__, -1, 1> alpha_prevalence_log;
      alpha_prevalence_log = Eigen::Matrix<local_scalar_t__, -1, 1>(NSB);
      stan::math::fill(alpha_prevalence_log, DUMMY_VAR__);
      
      current_statement__ = 23;
      assign(alpha_prevalence_log,
        subtract(
          multiply(2,
            subtract(sigma_prevalence,
              rvalue(sd_prevalence, "sd_prevalence", index_min_max(1, NSB)))),
          stan::math::log2()), "assigning variable alpha_prevalence_log");
      Eigen::Matrix<local_scalar_t__, -1, 1> alpha_abundance_log;
      alpha_abundance_log = Eigen::Matrix<local_scalar_t__, -1, 1>(NSB);
      stan::math::fill(alpha_abundance_log, DUMMY_VAR__);
      
      current_statement__ = 24;
      assign(alpha_abundance_log,
        subtract(
          multiply(2,
            subtract(sigma_abundance,
              rvalue(sd_abundance, "sd_abundance", index_min_max(1, NSB)))),
          stan::math::log2()), "assigning variable alpha_abundance_log");
      Eigen::Matrix<local_scalar_t__, -1, 1> alpha_prevalence;
      alpha_prevalence = Eigen::Matrix<local_scalar_t__, -1, 1>(NSB);
      stan::math::fill(alpha_prevalence, DUMMY_VAR__);
      
      current_statement__ = 25;
      assign(alpha_prevalence, stan::math::exp(alpha_prevalence_log),
        "assigning variable alpha_prevalence");
      Eigen::Matrix<local_scalar_t__, -1, 1> alpha_abundance;
      alpha_abundance = Eigen::Matrix<local_scalar_t__, -1, 1>(NSB);
      stan::math::fill(alpha_abundance, DUMMY_VAR__);
      
      current_statement__ = 26;
      assign(alpha_abundance, stan::math::exp(alpha_abundance_log),
        "assigning variable alpha_abundance");
      Eigen::Matrix<local_scalar_t__, -1, -1> beta_prevalence;
      beta_prevalence = Eigen::Matrix<local_scalar_t__, -1, -1>(NB_s, NN);
      stan::math::fill(beta_prevalence, DUMMY_VAR__);
      
      Eigen::Matrix<local_scalar_t__, -1, -1> beta_abundance;
      beta_abundance = Eigen::Matrix<local_scalar_t__, -1, -1>(NB_s, NN);
      stan::math::fill(beta_abundance, DUMMY_VAR__);
      
      current_statement__ = 29;
      assign(time_absolute, 1,
        "assigning variable time_absolute", index_uni(rvalue(self, "self",
                                                        index_uni(1))));
      current_statement__ = 30;
      assign(time, 1,
        "assigning variable time", index_uni(rvalue(self, "self",
                                               index_uni(1))));
      {
        int i;
        i = std::numeric_limits<int>::min();
        
        current_statement__ = 31;
        i = 1;
        current_statement__ = 41;
        for (int m = 2; m <= NN; ++m) {
          current_statement__ = 39;
          if (logical_gt(rvalue(self, "self", index_uni(m)), NT)) {
            current_statement__ = 35;
            assign(time_absolute,
              (rvalue(time_absolute, "time_absolute",
                 index_uni(rvalue(ancestor, "ancestor", index_uni(m)))) *
                rvalue(time_raw, "time_raw", index_uni(i))),
              "assigning variable time_absolute", index_uni(rvalue(self,
                                                              "self",
                                                              index_uni(m))));
            current_statement__ = 36;
            assign(time,
              (rvalue(time_absolute, "time_absolute",
                 index_uni(rvalue(ancestor, "ancestor", index_uni(m)))) -
                rvalue(time_absolute, "time_absolute",
                  index_uni(rvalue(self, "self", index_uni(m))))),
              "assigning variable time", index_uni(rvalue(self, "self",
                                                     index_uni(m))));
            current_statement__ = 37;
            i = (i + 1);
          } else {
            current_statement__ = 32;
            assign(time_absolute, 0,
              "assigning variable time_absolute", index_uni(rvalue(self,
                                                              "self",
                                                              index_uni(m))));
            current_statement__ = 33;
            assign(time,
              rvalue(time_absolute, "time_absolute",
                index_uni(rvalue(ancestor, "ancestor", index_uni(m)))),
              "assigning variable time", index_uni(rvalue(self, "self",
                                                     index_uni(m))));
          }
        }
      }
      current_statement__ = 43;
      assign(time_sqrt, stan::math::sqrt(time),
        "assigning variable time_sqrt");
      current_statement__ = 44;
      assign(time_log, stan::math::log(time), "assigning variable time_log");
      current_statement__ = 45;
      assign(beta_prevalence,
        add(theta_prevalence,
          elt_multiply(
            rvalue(sd_prevalence, "sd_prevalence", index_multi(idx)),
            rvalue(delta_prevalence, "delta_prevalence",
              index_omni(), index_uni(rvalue(self, "self", index_uni(1)))))),
        "assigning variable beta_prevalence", index_omni(),
                                                index_uni(rvalue(self,
                                                            "self",
                                                            index_uni(1))));
      current_statement__ = 46;
      assign(beta_abundance, zeros_vector(NB_s),
        "assigning variable beta_abundance", index_omni(),
                                               index_uni(rvalue(self, "self",
                                                           index_uni(1))));
      current_statement__ = 54;
      for (int m = 2; m <= NN; ++m) {
        current_statement__ = 47;
        validate_non_negative_index("natp", "NSB", NSB);
        Eigen::Matrix<local_scalar_t__, -1, 1> natp;
        natp = Eigen::Matrix<local_scalar_t__, -1, 1>(NSB);
        stan::math::fill(natp, DUMMY_VAR__);
        
        current_statement__ = 48;
        assign(natp,
          minus(
            stan::math::exp(
              add(alpha_prevalence_log,
                rvalue(time_log, "time_log",
                  index_uni(rvalue(self, "self", index_uni(m))))))),
          "assigning variable natp");
        current_statement__ = 49;
        validate_non_negative_index("nata", "NSB", NSB);
        Eigen::Matrix<local_scalar_t__, -1, 1> nata;
        nata = Eigen::Matrix<local_scalar_t__, -1, 1>(NSB);
        stan::math::fill(nata, DUMMY_VAR__);
        
        current_statement__ = 50;
        assign(nata,
          minus(
            stan::math::exp(
              add(alpha_abundance_log,
                rvalue(time_log, "time_log",
                  index_uni(rvalue(self, "self", index_uni(m))))))),
          "assigning variable nata");
        current_statement__ = 51;
        assign(beta_prevalence,
          add(
            add(
              elt_multiply(
                rvalue(stan::math::exp(natp), "exp(natp)", index_multi(idx)),
                stan::model::deep_copy(
                  rvalue(beta_prevalence, "beta_prevalence",
                    index_omni(),
                      index_uni(rvalue(ancestor, "ancestor", index_uni(m)))))),
              elt_multiply(
                rvalue(subtract(1, stan::math::exp(natp)), "(1 - exp(natp))",
                  index_multi(idx)), theta_prevalence)),
            elt_multiply(
              elt_multiply(
                rvalue(sigma_prevalence, "sigma_prevalence",
                  index_multi(idx)),
                stan::math::exp(
                  subtract(
                    subtract(
                      multiply(0.5,
                        log1m_exp(
                          multiply(2, rvalue(natp, "natp", index_multi(idx))))),
                      rvalue(
                        subtract(sigma_prevalence,
  rvalue(sd_prevalence, "sd_prevalence", index_min_max(1, NSB))),
                        "(sigma_prevalence - sd_prevalence[1:NSB])",
                        index_multi(idx))), stan::math::log2()))),
              rvalue(delta_prevalence, "delta_prevalence",
                index_omni(), index_uni(rvalue(self, "self", index_uni(m)))))),
          "assigning variable beta_prevalence", index_omni(),
                                                  index_uni(rvalue(self,
                                                              "self",
                                                              index_uni(m))));
        current_statement__ = 52;
        assign(beta_abundance,
          add(
            elt_multiply(
              rvalue(stan::math::exp(nata), "exp(nata)", index_multi(idx)),
              stan::model::deep_copy(
                rvalue(beta_abundance, "beta_abundance",
                  index_omni(),
                    index_uni(rvalue(ancestor, "ancestor", index_uni(m)))))),
            elt_multiply(
              elt_multiply(
                rvalue(sigma_abundance, "sigma_abundance", index_multi(idx)),
                stan::math::exp(
                  subtract(
                    subtract(
                      multiply(0.5,
                        log1m_exp(
                          multiply(2, rvalue(nata, "nata", index_multi(idx))))),
                      rvalue(
                        subtract(sigma_abundance,
  rvalue(sd_abundance, "sd_abundance", index_min_max(1, NSB))),
                        "(sigma_abundance - sd_abundance[1:NSB])",
                        index_multi(idx))), stan::math::log2()))),
              rvalue(delta_abundance, "delta_abundance",
                index_omni(), index_uni(rvalue(self, "self", index_uni(m)))))),
          "assigning variable beta_abundance", index_omni(),
                                                 index_uni(rvalue(self,
                                                             "self",
                                                             index_uni(m))));
      }
      {
        current_statement__ = 55;
        validate_non_negative_index("prevalence", "NS", NS);
        current_statement__ = 56;
        validate_non_negative_index("prevalence", "NN", NN);
        Eigen::Matrix<local_scalar_t__, -1, -1> prevalence;
        prevalence = Eigen::Matrix<local_scalar_t__, -1, -1>(NS, NN);
        stan::math::fill(prevalence, DUMMY_VAR__);
        
        current_statement__ = 57;
        assign(prevalence, multiply(X_s, beta_prevalence),
          "assigning variable prevalence");
        current_statement__ = 58;
        validate_non_negative_index("abundance_predicted", "NS", NS);
        current_statement__ = 59;
        validate_non_negative_index("abundance_predicted", "NN", NN);
        Eigen::Matrix<local_scalar_t__, -1, -1> abundance_predicted;
        abundance_predicted = Eigen::Matrix<local_scalar_t__, -1, -1>(NS, NN);
        stan::math::fill(abundance_predicted, DUMMY_VAR__);
        
        current_statement__ = 60;
        assign(abundance_predicted, multiply(X_s, beta_abundance),
          "assigning variable abundance_predicted");
        current_statement__ = 61;
        validate_non_negative_index("abundance_contam", "NS", NS);
        current_statement__ = 62;
        validate_non_negative_index("abundance_contam", "NN", NN);
        Eigen::Matrix<local_scalar_t__, -1, -1> abundance_contam;
        abundance_contam = Eigen::Matrix<local_scalar_t__, -1, -1>(NS, NN);
        stan::math::fill(abundance_contam, DUMMY_VAR__);
        
        current_statement__ = 63;
        assign(abundance_contam,
          rep_matrix(
            add(
              add(
                rvalue(beta_abundance, "beta_abundance",
                  index_uni(1), index_omni()),
                log_inv_logit(
                  rvalue(beta_prevalence, "beta_prevalence",
                    index_uni(1), index_omni()))), log_less_contamination),
            NS), "assigning variable abundance_contam");
        current_statement__ = 64;
        lp_accum__.add(student_t_lpdf<false>(seq_div_rate, 5, 0, 2.5));
        current_statement__ = 65;
        lp_accum__.add(
          student_t_lpdf<false>(global_scale_prevalence, 5, 0, 2.5));
        current_statement__ = 66;
        lp_accum__.add(
          student_t_lpdf<false>(global_scale_abundance, 5, 0, 2.5));
        current_statement__ = 67;
        lp_accum__.add(student_t_lpdf<false>(sigma_prevalence, 5, 0, 2.5));
        current_statement__ = 68;
        lp_accum__.add(student_t_lpdf<false>(sigma_abundance, 5, 0, 2.5));
        current_statement__ = 69;
        lp_accum__.add(
          student_t_lpdf<false>(theta_prevalence, 5, 0,
            rvalue(
              rvalue(sd_prevalence, "sd_prevalence", index_min_max((NSB + 1), (2 * NSB))),
              "sd_prevalence[(NSB + 1):(2 * NSB)]", index_multi(idx))));
        current_statement__ = 70;
        lp_accum__.add(
          student_t_lpdf<false>(to_vector(delta_prevalence), 5, 0, 1));
        current_statement__ = 71;
        lp_accum__.add(
          student_t_lpdf<false>(to_vector(delta_abundance), 5, 0, 1));
        current_statement__ = 72;
        lp_accum__.add(
          generalized_std_normal_1_lpdf<false>(
            (inv_log_less_contamination / inv_log_max_contam),
            shape_gnorm, pstream__));
        current_statement__ = 73;
        lp_accum__.add(lognormal_lpdf<false>(contaminant_overdisp, 0, 0.1));
        current_statement__ = 74;
        lp_accum__.add(
          student_t_lpdf<false>(divergence, 5, 0,
            multiply(seq_div_rate,
              append_row(
                rvalue(time_sqrt, "time_sqrt", index_min_max(1, NT)),
                rvalue(time_sqrt, "time_sqrt", index_min_max((NT + 2), NN))))));
        current_statement__ = 79;
        for (int m = 1; m <= NT; ++m) {
          current_statement__ = 77;
          for (int s = 1; s <= NS; ++s) {
            current_statement__ = 75;
            lp_accum__.add(
              log_sum_exp(
                (log1m_inv_logit(
                   rvalue(prevalence, "prevalence",
                     index_uni(s), index_uni(m))) +
                  student_t_lpdf<false>(
                    rvalue(abundance_observed, "abundance_observed",
                      index_uni(s), index_uni(m)), 5,
                    rvalue(abundance_contam, "abundance_contam",
                      index_uni(s), index_uni(m)),
                    (contaminant_overdisp *
                      rvalue(sd_abundance, "sd_abundance",
                        index_uni((NSB + 1)))))),
                (log_inv_logit(
                   rvalue(prevalence, "prevalence",
                     index_uni(s), index_uni(m))) +
                  student_t_lpdf<false>(
                    rvalue(abundance_observed, "abundance_observed",
                      index_uni(s), index_uni(m)), 5,
                    log_sum_exp(
                      rvalue(abundance_contam, "abundance_contam",
                        index_uni(s), index_uni(m)),
                      rvalue(abundance_predicted, "abundance_predicted",
                        index_uni(s), index_uni(m))),
                    rvalue(sd_abundance, "sd_abundance",
                      index_uni((NSB + 1)))))));
          }
        }
        current_statement__ = 80;
        lp_accum__.add(
          poisson_log_lpmf<false>(to_array_1d(count),
            to_vector(
              add(abundance_observed, rep_matrix(multinomial_nuisance, NT)))));
      }
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    lp_accum__.add(lp__);
    return lp_accum__.sum();
    } // log_prob_impl() 
    
  template <typename RNG, typename VecR, typename VecI, typename VecVar, 
  stan::require_vector_like_vt<std::is_floating_point, VecR>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr, 
  stan::require_std_vector_vt<std::is_floating_point, VecVar>* = nullptr> 
  inline void write_array_impl(RNG& base_rng__, VecR& params_r__,
                               VecI& params_i__, VecVar& vars__,
                               const bool emit_transformed_parameters__ = true,
                               const bool emit_generated_quantities__ = true,
                               std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.resize(0);
    stan::io::deserializer<local_scalar_t__> in__(params_r__, params_i__);
    static constexpr bool propto__ = true;
    (void) propto__;
    double lp__ = 0.0;
    (void) lp__;  // dummy to suppress unused var warning
    int current_statement__ = 0; 
    stan::math::accumulator<double> lp_accum__;
    local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
    constexpr bool jacobian__ = false;
    (void) DUMMY_VAR__;  // suppress unused var warning
    static constexpr const char* function__ = "lvip_glm_model_namespace::write_array";
    (void) function__;  // suppress unused var warning
    
    try {
      Eigen::Matrix<double, -1, 1> time_raw;
      time_raw = Eigen::Matrix<double, -1, 1>(time_raw_1dim__);
      stan::math::fill(time_raw, std::numeric_limits<double>::quiet_NaN());
      
      current_statement__ = 1;
      time_raw = in__.template read_constrain_lub<Eigen::Matrix<local_scalar_t__, -1, 1>, jacobian__>(
                   0, 1, lp__, time_raw_1dim__);
      double seq_div_rate;
      seq_div_rate = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      seq_div_rate = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(
                       0, lp__);
      double global_scale_prevalence;
      global_scale_prevalence = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 3;
      global_scale_prevalence = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(
                                  0, lp__);
      double global_scale_abundance;
      global_scale_abundance = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 4;
      global_scale_abundance = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(
                                 0, lp__);
      Eigen::Matrix<double, -1, 1> var_prop_prevalence;
      var_prop_prevalence = Eigen::Matrix<double, -1, 1>(var_prop_prevalence_1dim__);
      stan::math::fill(var_prop_prevalence, std::numeric_limits<double>::quiet_NaN());
      
      
      current_statement__ = 5;
      var_prop_prevalence = in__.template read_constrain_simplex<Eigen::Matrix<local_scalar_t__, -1, 1>, jacobian__>(
                              lp__, var_prop_prevalence_1dim__);
      Eigen::Matrix<double, -1, 1> var_prop_abundance;
      var_prop_abundance = Eigen::Matrix<double, -1, 1>(var_prop_abundance_1dim__);
      stan::math::fill(var_prop_abundance, std::numeric_limits<double>::quiet_NaN());
      
      
      current_statement__ = 6;
      var_prop_abundance = in__.template read_constrain_simplex<Eigen::Matrix<local_scalar_t__, -1, 1>, jacobian__>(
                             lp__, var_prop_abundance_1dim__);
      Eigen::Matrix<double, -1, 1> sigma_prevalence;
      sigma_prevalence = Eigen::Matrix<double, -1, 1>(NSB);
      stan::math::fill(sigma_prevalence, std::numeric_limits<double>::quiet_NaN());
      
      
      current_statement__ = 7;
      sigma_prevalence = in__.template read_constrain_lb<Eigen::Matrix<local_scalar_t__, -1, 1>, jacobian__>(
                           0, lp__, NSB);
      Eigen::Matrix<double, -1, 1> sigma_abundance;
      sigma_abundance = Eigen::Matrix<double, -1, 1>(NSB);
      stan::math::fill(sigma_abundance, std::numeric_limits<double>::quiet_NaN());
      
      
      current_statement__ = 8;
      sigma_abundance = in__.template read_constrain_lb<Eigen::Matrix<local_scalar_t__, -1, 1>, jacobian__>(
                          0, lp__, NSB);
      Eigen::Matrix<double, -1, 1> theta_prevalence;
      theta_prevalence = Eigen::Matrix<double, -1, 1>(NB_s);
      stan::math::fill(theta_prevalence, std::numeric_limits<double>::quiet_NaN());
      
      
      current_statement__ = 9;
      theta_prevalence = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                           NB_s);
      Eigen::Matrix<double, -1, -1> delta_prevalence;
      delta_prevalence = Eigen::Matrix<double, -1, -1>(NB_s, NN);
      stan::math::fill(delta_prevalence, std::numeric_limits<double>::quiet_NaN());
      
      
      current_statement__ = 10;
      delta_prevalence = in__.template read<Eigen::Matrix<local_scalar_t__, -1, -1>>(
                           NB_s, NN);
      Eigen::Matrix<double, -1, -1> delta_abundance;
      delta_abundance = Eigen::Matrix<double, -1, -1>(NB_s, NN);
      stan::math::fill(delta_abundance, std::numeric_limits<double>::quiet_NaN());
      
      
      current_statement__ = 11;
      delta_abundance = in__.template read<Eigen::Matrix<local_scalar_t__, -1, -1>>(
                          NB_s, NN);
      Eigen::Matrix<double, -1, -1> abundance_observed;
      abundance_observed = Eigen::Matrix<double, -1, -1>(NS, NT);
      stan::math::fill(abundance_observed, std::numeric_limits<double>::quiet_NaN());
      
      
      current_statement__ = 12;
      abundance_observed = in__.template read<Eigen::Matrix<local_scalar_t__, -1, -1>>(
                             NS, NT);
      Eigen::Matrix<double, -1, 1> multinomial_nuisance;
      multinomial_nuisance = Eigen::Matrix<double, -1, 1>(NS);
      stan::math::fill(multinomial_nuisance, std::numeric_limits<double>::quiet_NaN());
      
      
      current_statement__ = 13;
      multinomial_nuisance = in__.template read<Eigen::Matrix<local_scalar_t__, -1, 1>>(
                               NS);
      double inv_log_less_contamination;
      inv_log_less_contamination = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 14;
      inv_log_less_contamination = in__.template read_constrain_ub<local_scalar_t__, jacobian__>(
                                     0, lp__);
      double contaminant_overdisp;
      contaminant_overdisp = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 15;
      contaminant_overdisp = in__.template read_constrain_lb<local_scalar_t__, jacobian__>(
                               0, lp__);
      Eigen::Matrix<double, -1, 1> time_absolute;
      time_absolute = Eigen::Matrix<double, -1, 1>(NN);
      stan::math::fill(time_absolute, std::numeric_limits<double>::quiet_NaN());
      
      
      Eigen::Matrix<double, -1, 1> time;
      time = Eigen::Matrix<double, -1, 1>(NN);
      stan::math::fill(time, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, 1> time_sqrt;
      time_sqrt = Eigen::Matrix<double, -1, 1>(NN);
      stan::math::fill(time_sqrt, std::numeric_limits<double>::quiet_NaN());
      
      Eigen::Matrix<double, -1, 1> time_log;
      time_log = Eigen::Matrix<double, -1, 1>(NN);
      stan::math::fill(time_log, std::numeric_limits<double>::quiet_NaN());
      
      double log_less_contamination;
      log_less_contamination = std::numeric_limits<double>::quiet_NaN();
      
      Eigen::Matrix<double, -1, 1> sd_prevalence;
      sd_prevalence = Eigen::Matrix<double, -1, 1>(sd_prevalence_1dim__);
      stan::math::fill(sd_prevalence, std::numeric_limits<double>::quiet_NaN());
      
      
      Eigen::Matrix<double, -1, 1> sd_abundance;
      sd_abundance = Eigen::Matrix<double, -1, 1>(sd_abundance_1dim__);
      stan::math::fill(sd_abundance, std::numeric_limits<double>::quiet_NaN());
      
      
      Eigen::Matrix<double, -1, 1> alpha_prevalence_log;
      alpha_prevalence_log = Eigen::Matrix<double, -1, 1>(NSB);
      stan::math::fill(alpha_prevalence_log, std::numeric_limits<double>::quiet_NaN());
      
      
      Eigen::Matrix<double, -1, 1> alpha_abundance_log;
      alpha_abundance_log = Eigen::Matrix<double, -1, 1>(NSB);
      stan::math::fill(alpha_abundance_log, std::numeric_limits<double>::quiet_NaN());
      
      
      Eigen::Matrix<double, -1, 1> alpha_prevalence;
      alpha_prevalence = Eigen::Matrix<double, -1, 1>(NSB);
      stan::math::fill(alpha_prevalence, std::numeric_limits<double>::quiet_NaN());
      
      
      Eigen::Matrix<double, -1, 1> alpha_abundance;
      alpha_abundance = Eigen::Matrix<double, -1, 1>(NSB);
      stan::math::fill(alpha_abundance, std::numeric_limits<double>::quiet_NaN());
      
      
      Eigen::Matrix<double, -1, -1> beta_prevalence;
      beta_prevalence = Eigen::Matrix<double, -1, -1>(NB_s, NN);
      stan::math::fill(beta_prevalence, std::numeric_limits<double>::quiet_NaN());
      
      
      Eigen::Matrix<double, -1, -1> beta_abundance;
      beta_abundance = Eigen::Matrix<double, -1, -1>(NB_s, NN);
      stan::math::fill(beta_abundance, std::numeric_limits<double>::quiet_NaN());
      
      
      for (int sym1__ = 1; sym1__ <= time_raw_1dim__; ++sym1__) {
        vars__.emplace_back(time_raw[(sym1__ - 1)]);
      }
      vars__.emplace_back(seq_div_rate);
      vars__.emplace_back(global_scale_prevalence);
      vars__.emplace_back(global_scale_abundance);
      for (int sym1__ = 1; sym1__ <= var_prop_prevalence_1dim__; ++sym1__) {
        vars__.emplace_back(var_prop_prevalence[(sym1__ - 1)]);
      }
      for (int sym1__ = 1; sym1__ <= var_prop_abundance_1dim__; ++sym1__) {
        vars__.emplace_back(var_prop_abundance[(sym1__ - 1)]);
      }
      for (int sym1__ = 1; sym1__ <= NSB; ++sym1__) {
        vars__.emplace_back(sigma_prevalence[(sym1__ - 1)]);
      }
      for (int sym1__ = 1; sym1__ <= NSB; ++sym1__) {
        vars__.emplace_back(sigma_abundance[(sym1__ - 1)]);
      }
      for (int sym1__ = 1; sym1__ <= NB_s; ++sym1__) {
        vars__.emplace_back(theta_prevalence[(sym1__ - 1)]);
      }
      for (int sym1__ = 1; sym1__ <= NN; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= NB_s; ++sym2__) {
          vars__.emplace_back(
            rvalue(delta_prevalence, "delta_prevalence",
              index_uni(sym2__), index_uni(sym1__)));
        }
      }
      for (int sym1__ = 1; sym1__ <= NN; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= NB_s; ++sym2__) {
          vars__.emplace_back(
            rvalue(delta_abundance, "delta_abundance",
              index_uni(sym2__), index_uni(sym1__)));
        }
      }
      for (int sym1__ = 1; sym1__ <= NT; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= NS; ++sym2__) {
          vars__.emplace_back(
            rvalue(abundance_observed, "abundance_observed",
              index_uni(sym2__), index_uni(sym1__)));
        }
      }
      for (int sym1__ = 1; sym1__ <= NS; ++sym1__) {
        vars__.emplace_back(multinomial_nuisance[(sym1__ - 1)]);
      }
      vars__.emplace_back(inv_log_less_contamination);
      vars__.emplace_back(contaminant_overdisp);
      if (logical_negation((primitive_value(emit_transformed_parameters__) ||
            primitive_value(emit_generated_quantities__)))) {
        return ;
      } 
      current_statement__ = 20;
      log_less_contamination = inv(inv_log_less_contamination);
      current_statement__ = 21;
      assign(sd_prevalence,
        multiply(stan::math::sqrt(var_prop_prevalence),
          global_scale_prevalence), "assigning variable sd_prevalence");
      current_statement__ = 22;
      assign(sd_abundance,
        multiply(stan::math::sqrt(var_prop_abundance),
          global_scale_abundance), "assigning variable sd_abundance");
      current_statement__ = 23;
      assign(alpha_prevalence_log,
        subtract(
          multiply(2,
            subtract(sigma_prevalence,
              rvalue(sd_prevalence, "sd_prevalence", index_min_max(1, NSB)))),
          stan::math::log2()), "assigning variable alpha_prevalence_log");
      current_statement__ = 24;
      assign(alpha_abundance_log,
        subtract(
          multiply(2,
            subtract(sigma_abundance,
              rvalue(sd_abundance, "sd_abundance", index_min_max(1, NSB)))),
          stan::math::log2()), "assigning variable alpha_abundance_log");
      current_statement__ = 25;
      assign(alpha_prevalence, stan::math::exp(alpha_prevalence_log),
        "assigning variable alpha_prevalence");
      current_statement__ = 26;
      assign(alpha_abundance, stan::math::exp(alpha_abundance_log),
        "assigning variable alpha_abundance");
      current_statement__ = 29;
      assign(time_absolute, 1,
        "assigning variable time_absolute", index_uni(rvalue(self, "self",
                                                        index_uni(1))));
      current_statement__ = 30;
      assign(time, 1,
        "assigning variable time", index_uni(rvalue(self, "self",
                                               index_uni(1))));
      {
        int i;
        i = std::numeric_limits<int>::min();
        
        current_statement__ = 31;
        i = 1;
        current_statement__ = 41;
        for (int m = 2; m <= NN; ++m) {
          current_statement__ = 39;
          if (logical_gt(rvalue(self, "self", index_uni(m)), NT)) {
            current_statement__ = 35;
            assign(time_absolute,
              (rvalue(time_absolute, "time_absolute",
                 index_uni(rvalue(ancestor, "ancestor", index_uni(m)))) *
                rvalue(time_raw, "time_raw", index_uni(i))),
              "assigning variable time_absolute", index_uni(rvalue(self,
                                                              "self",
                                                              index_uni(m))));
            current_statement__ = 36;
            assign(time,
              (rvalue(time_absolute, "time_absolute",
                 index_uni(rvalue(ancestor, "ancestor", index_uni(m)))) -
                rvalue(time_absolute, "time_absolute",
                  index_uni(rvalue(self, "self", index_uni(m))))),
              "assigning variable time", index_uni(rvalue(self, "self",
                                                     index_uni(m))));
            current_statement__ = 37;
            i = (i + 1);
          } else {
            current_statement__ = 32;
            assign(time_absolute, 0,
              "assigning variable time_absolute", index_uni(rvalue(self,
                                                              "self",
                                                              index_uni(m))));
            current_statement__ = 33;
            assign(time,
              rvalue(time_absolute, "time_absolute",
                index_uni(rvalue(ancestor, "ancestor", index_uni(m)))),
              "assigning variable time", index_uni(rvalue(self, "self",
                                                     index_uni(m))));
          }
        }
      }
      current_statement__ = 43;
      assign(time_sqrt, stan::math::sqrt(time),
        "assigning variable time_sqrt");
      current_statement__ = 44;
      assign(time_log, stan::math::log(time), "assigning variable time_log");
      current_statement__ = 45;
      assign(beta_prevalence,
        add(theta_prevalence,
          elt_multiply(
            rvalue(sd_prevalence, "sd_prevalence", index_multi(idx)),
            rvalue(delta_prevalence, "delta_prevalence",
              index_omni(), index_uni(rvalue(self, "self", index_uni(1)))))),
        "assigning variable beta_prevalence", index_omni(),
                                                index_uni(rvalue(self,
                                                            "self",
                                                            index_uni(1))));
      current_statement__ = 46;
      assign(beta_abundance, zeros_vector(NB_s),
        "assigning variable beta_abundance", index_omni(),
                                               index_uni(rvalue(self, "self",
                                                           index_uni(1))));
      current_statement__ = 54;
      for (int m = 2; m <= NN; ++m) {
        current_statement__ = 47;
        validate_non_negative_index("natp", "NSB", NSB);
        Eigen::Matrix<double, -1, 1> natp;
        natp = Eigen::Matrix<double, -1, 1>(NSB);
        stan::math::fill(natp, std::numeric_limits<double>::quiet_NaN());
        
        current_statement__ = 48;
        assign(natp,
          minus(
            stan::math::exp(
              add(alpha_prevalence_log,
                rvalue(time_log, "time_log",
                  index_uni(rvalue(self, "self", index_uni(m))))))),
          "assigning variable natp");
        current_statement__ = 49;
        validate_non_negative_index("nata", "NSB", NSB);
        Eigen::Matrix<double, -1, 1> nata;
        nata = Eigen::Matrix<double, -1, 1>(NSB);
        stan::math::fill(nata, std::numeric_limits<double>::quiet_NaN());
        
        current_statement__ = 50;
        assign(nata,
          minus(
            stan::math::exp(
              add(alpha_abundance_log,
                rvalue(time_log, "time_log",
                  index_uni(rvalue(self, "self", index_uni(m))))))),
          "assigning variable nata");
        current_statement__ = 51;
        assign(beta_prevalence,
          add(
            add(
              elt_multiply(
                rvalue(stan::math::exp(natp), "exp(natp)", index_multi(idx)),
                stan::model::deep_copy(
                  rvalue(beta_prevalence, "beta_prevalence",
                    index_omni(),
                      index_uni(rvalue(ancestor, "ancestor", index_uni(m)))))),
              elt_multiply(
                rvalue(subtract(1, stan::math::exp(natp)), "(1 - exp(natp))",
                  index_multi(idx)), theta_prevalence)),
            elt_multiply(
              elt_multiply(
                rvalue(sigma_prevalence, "sigma_prevalence",
                  index_multi(idx)),
                stan::math::exp(
                  subtract(
                    subtract(
                      multiply(0.5,
                        log1m_exp(
                          multiply(2, rvalue(natp, "natp", index_multi(idx))))),
                      rvalue(
                        subtract(sigma_prevalence,
  rvalue(sd_prevalence, "sd_prevalence", index_min_max(1, NSB))),
                        "(sigma_prevalence - sd_prevalence[1:NSB])",
                        index_multi(idx))), stan::math::log2()))),
              rvalue(delta_prevalence, "delta_prevalence",
                index_omni(), index_uni(rvalue(self, "self", index_uni(m)))))),
          "assigning variable beta_prevalence", index_omni(),
                                                  index_uni(rvalue(self,
                                                              "self",
                                                              index_uni(m))));
        current_statement__ = 52;
        assign(beta_abundance,
          add(
            elt_multiply(
              rvalue(stan::math::exp(nata), "exp(nata)", index_multi(idx)),
              stan::model::deep_copy(
                rvalue(beta_abundance, "beta_abundance",
                  index_omni(),
                    index_uni(rvalue(ancestor, "ancestor", index_uni(m)))))),
            elt_multiply(
              elt_multiply(
                rvalue(sigma_abundance, "sigma_abundance", index_multi(idx)),
                stan::math::exp(
                  subtract(
                    subtract(
                      multiply(0.5,
                        log1m_exp(
                          multiply(2, rvalue(nata, "nata", index_multi(idx))))),
                      rvalue(
                        subtract(sigma_abundance,
  rvalue(sd_abundance, "sd_abundance", index_min_max(1, NSB))),
                        "(sigma_abundance - sd_abundance[1:NSB])",
                        index_multi(idx))), stan::math::log2()))),
              rvalue(delta_abundance, "delta_abundance",
                index_omni(), index_uni(rvalue(self, "self", index_uni(m)))))),
          "assigning variable beta_abundance", index_omni(),
                                                 index_uni(rvalue(self,
                                                             "self",
                                                             index_uni(m))));
      }
      if (emit_transformed_parameters__) {
        for (int sym1__ = 1; sym1__ <= NN; ++sym1__) {
          vars__.emplace_back(time_absolute[(sym1__ - 1)]);
        }
        for (int sym1__ = 1; sym1__ <= NN; ++sym1__) {
          vars__.emplace_back(time[(sym1__ - 1)]);
        }
        for (int sym1__ = 1; sym1__ <= NN; ++sym1__) {
          vars__.emplace_back(time_sqrt[(sym1__ - 1)]);
        }
        for (int sym1__ = 1; sym1__ <= NN; ++sym1__) {
          vars__.emplace_back(time_log[(sym1__ - 1)]);
        }
        vars__.emplace_back(log_less_contamination);
        for (int sym1__ = 1; sym1__ <= sd_prevalence_1dim__; ++sym1__) {
          vars__.emplace_back(sd_prevalence[(sym1__ - 1)]);
        }
        for (int sym1__ = 1; sym1__ <= sd_abundance_1dim__; ++sym1__) {
          vars__.emplace_back(sd_abundance[(sym1__ - 1)]);
        }
        for (int sym1__ = 1; sym1__ <= NSB; ++sym1__) {
          vars__.emplace_back(alpha_prevalence_log[(sym1__ - 1)]);
        }
        for (int sym1__ = 1; sym1__ <= NSB; ++sym1__) {
          vars__.emplace_back(alpha_abundance_log[(sym1__ - 1)]);
        }
        for (int sym1__ = 1; sym1__ <= NSB; ++sym1__) {
          vars__.emplace_back(alpha_prevalence[(sym1__ - 1)]);
        }
        for (int sym1__ = 1; sym1__ <= NSB; ++sym1__) {
          vars__.emplace_back(alpha_abundance[(sym1__ - 1)]);
        }
        for (int sym1__ = 1; sym1__ <= NN; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= NB_s; ++sym2__) {
            vars__.emplace_back(
              rvalue(beta_prevalence, "beta_prevalence",
                index_uni(sym2__), index_uni(sym1__)));
          }
        }
        for (int sym1__ = 1; sym1__ <= NN; ++sym1__) {
          for (int sym2__ = 1; sym2__ <= NB_s; ++sym2__) {
            vars__.emplace_back(
              rvalue(beta_abundance, "beta_abundance",
                index_uni(sym2__), index_uni(sym1__)));
          }
        }
      } 
      if (logical_negation(emit_generated_quantities__)) {
        return ;
      } 
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // write_array_impl() 
    
  template <typename VecVar, typename VecI, 
  stan::require_std_vector_t<VecVar>* = nullptr, 
  stan::require_vector_like_vt<std::is_integral, VecI>* = nullptr> 
  inline void transform_inits_impl(const stan::io::var_context& context__,
                                   VecI& params_i__, VecVar& vars__,
                                   std::ostream* pstream__ = nullptr) const {
    using local_scalar_t__ = double;
    vars__.clear();
    vars__.reserve(num_params_r__);
    int current_statement__ = 0; 
    
    try {
      int pos__;
      pos__ = std::numeric_limits<int>::min();
      
      pos__ = 1;
      Eigen::Matrix<double, -1, 1> time_raw;
      time_raw = Eigen::Matrix<double, -1, 1>(time_raw_1dim__);
      stan::math::fill(time_raw, std::numeric_limits<double>::quiet_NaN());
      
      {
        std::vector<local_scalar_t__> time_raw_flat__;
        current_statement__ = 1;
        time_raw_flat__ = context__.vals_r("time_raw");
        current_statement__ = 1;
        pos__ = 1;
        current_statement__ = 1;
        for (int sym1__ = 1; sym1__ <= time_raw_1dim__; ++sym1__) {
          current_statement__ = 1;
          assign(time_raw, time_raw_flat__[(pos__ - 1)],
            "assigning variable time_raw", index_uni(sym1__));
          current_statement__ = 1;
          pos__ = (pos__ + 1);
        }
      }
      Eigen::Matrix<double, -1, 1> time_raw_free__;
      time_raw_free__ = Eigen::Matrix<double, -1, 1>(time_raw_1dim__);
      stan::math::fill(time_raw_free__, std::numeric_limits<double>::quiet_NaN());
      
      
      current_statement__ = 1;
      for (int sym1__ = 1; sym1__ <= time_raw_1dim__; ++sym1__) {
        current_statement__ = 1;
        assign(time_raw_free__,
          stan::math::lub_free(time_raw[(sym1__ - 1)], 0, 1),
          "assigning variable time_raw_free__", index_uni(sym1__));
      }
      double seq_div_rate;
      seq_div_rate = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      seq_div_rate = context__.vals_r("seq_div_rate")[(1 - 1)];
      double seq_div_rate_free__;
      seq_div_rate_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 2;
      seq_div_rate_free__ = stan::math::lb_free(seq_div_rate, 0);
      double global_scale_prevalence;
      global_scale_prevalence = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 3;
      global_scale_prevalence = context__.vals_r("global_scale_prevalence")[
          (1 - 1)];
      double global_scale_prevalence_free__;
      global_scale_prevalence_free__ = std::numeric_limits<double>::quiet_NaN();
      
      
      current_statement__ = 3;
      global_scale_prevalence_free__ = stan::math::lb_free(
                                         global_scale_prevalence, 0);
      double global_scale_abundance;
      global_scale_abundance = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 4;
      global_scale_abundance = context__.vals_r("global_scale_abundance")[
          (1 - 1)];
      double global_scale_abundance_free__;
      global_scale_abundance_free__ = std::numeric_limits<double>::quiet_NaN();
      
      
      current_statement__ = 4;
      global_scale_abundance_free__ = stan::math::lb_free(
                                        global_scale_abundance, 0);
      Eigen::Matrix<double, -1, 1> var_prop_prevalence;
      var_prop_prevalence = Eigen::Matrix<double, -1, 1>(var_prop_prevalence_1dim__);
      stan::math::fill(var_prop_prevalence, std::numeric_limits<double>::quiet_NaN());
      
      
      {
        std::vector<local_scalar_t__> var_prop_prevalence_flat__;
        current_statement__ = 5;
        var_prop_prevalence_flat__ = context__.vals_r("var_prop_prevalence");
        current_statement__ = 5;
        pos__ = 1;
        current_statement__ = 5;
        for (int sym1__ = 1; sym1__ <= var_prop_prevalence_1dim__; ++sym1__) {
          current_statement__ = 5;
          assign(var_prop_prevalence,
            var_prop_prevalence_flat__[(pos__ - 1)],
            "assigning variable var_prop_prevalence", index_uni(sym1__));
          current_statement__ = 5;
          pos__ = (pos__ + 1);
        }
      }
      Eigen::Matrix<double, -1, 1> var_prop_prevalence_free__;
      var_prop_prevalence_free__ = Eigen::Matrix<double, -1, 1>((var_prop_prevalence_1dim__
                                                                  - 1));
      stan::math::fill(var_prop_prevalence_free__, std::numeric_limits<double>::quiet_NaN());
      
      
      current_statement__ = 5;
      assign(var_prop_prevalence_free__,
        stan::math::simplex_free(var_prop_prevalence),
        "assigning variable var_prop_prevalence_free__");
      Eigen::Matrix<double, -1, 1> var_prop_abundance;
      var_prop_abundance = Eigen::Matrix<double, -1, 1>(var_prop_abundance_1dim__);
      stan::math::fill(var_prop_abundance, std::numeric_limits<double>::quiet_NaN());
      
      
      {
        std::vector<local_scalar_t__> var_prop_abundance_flat__;
        current_statement__ = 6;
        var_prop_abundance_flat__ = context__.vals_r("var_prop_abundance");
        current_statement__ = 6;
        pos__ = 1;
        current_statement__ = 6;
        for (int sym1__ = 1; sym1__ <= var_prop_abundance_1dim__; ++sym1__) {
          current_statement__ = 6;
          assign(var_prop_abundance, var_prop_abundance_flat__[(pos__ - 1)],
            "assigning variable var_prop_abundance", index_uni(sym1__));
          current_statement__ = 6;
          pos__ = (pos__ + 1);
        }
      }
      Eigen::Matrix<double, -1, 1> var_prop_abundance_free__;
      var_prop_abundance_free__ = Eigen::Matrix<double, -1, 1>((var_prop_abundance_1dim__
                                                                 - 1));
      stan::math::fill(var_prop_abundance_free__, std::numeric_limits<double>::quiet_NaN());
      
      
      current_statement__ = 6;
      assign(var_prop_abundance_free__,
        stan::math::simplex_free(var_prop_abundance),
        "assigning variable var_prop_abundance_free__");
      Eigen::Matrix<double, -1, 1> sigma_prevalence;
      sigma_prevalence = Eigen::Matrix<double, -1, 1>(NSB);
      stan::math::fill(sigma_prevalence, std::numeric_limits<double>::quiet_NaN());
      
      
      {
        std::vector<local_scalar_t__> sigma_prevalence_flat__;
        current_statement__ = 7;
        sigma_prevalence_flat__ = context__.vals_r("sigma_prevalence");
        current_statement__ = 7;
        pos__ = 1;
        current_statement__ = 7;
        for (int sym1__ = 1; sym1__ <= NSB; ++sym1__) {
          current_statement__ = 7;
          assign(sigma_prevalence, sigma_prevalence_flat__[(pos__ - 1)],
            "assigning variable sigma_prevalence", index_uni(sym1__));
          current_statement__ = 7;
          pos__ = (pos__ + 1);
        }
      }
      Eigen::Matrix<double, -1, 1> sigma_prevalence_free__;
      sigma_prevalence_free__ = Eigen::Matrix<double, -1, 1>(NSB);
      stan::math::fill(sigma_prevalence_free__, std::numeric_limits<double>::quiet_NaN());
      
      
      current_statement__ = 7;
      for (int sym1__ = 1; sym1__ <= NSB; ++sym1__) {
        current_statement__ = 7;
        assign(sigma_prevalence_free__,
          stan::math::lb_free(sigma_prevalence[(sym1__ - 1)], 0),
          "assigning variable sigma_prevalence_free__", index_uni(sym1__));
      }
      Eigen::Matrix<double, -1, 1> sigma_abundance;
      sigma_abundance = Eigen::Matrix<double, -1, 1>(NSB);
      stan::math::fill(sigma_abundance, std::numeric_limits<double>::quiet_NaN());
      
      
      {
        std::vector<local_scalar_t__> sigma_abundance_flat__;
        current_statement__ = 8;
        sigma_abundance_flat__ = context__.vals_r("sigma_abundance");
        current_statement__ = 8;
        pos__ = 1;
        current_statement__ = 8;
        for (int sym1__ = 1; sym1__ <= NSB; ++sym1__) {
          current_statement__ = 8;
          assign(sigma_abundance, sigma_abundance_flat__[(pos__ - 1)],
            "assigning variable sigma_abundance", index_uni(sym1__));
          current_statement__ = 8;
          pos__ = (pos__ + 1);
        }
      }
      Eigen::Matrix<double, -1, 1> sigma_abundance_free__;
      sigma_abundance_free__ = Eigen::Matrix<double, -1, 1>(NSB);
      stan::math::fill(sigma_abundance_free__, std::numeric_limits<double>::quiet_NaN());
      
      
      current_statement__ = 8;
      for (int sym1__ = 1; sym1__ <= NSB; ++sym1__) {
        current_statement__ = 8;
        assign(sigma_abundance_free__,
          stan::math::lb_free(sigma_abundance[(sym1__ - 1)], 0),
          "assigning variable sigma_abundance_free__", index_uni(sym1__));
      }
      Eigen::Matrix<double, -1, 1> theta_prevalence;
      theta_prevalence = Eigen::Matrix<double, -1, 1>(NB_s);
      stan::math::fill(theta_prevalence, std::numeric_limits<double>::quiet_NaN());
      
      
      {
        std::vector<local_scalar_t__> theta_prevalence_flat__;
        current_statement__ = 9;
        theta_prevalence_flat__ = context__.vals_r("theta_prevalence");
        current_statement__ = 9;
        pos__ = 1;
        current_statement__ = 9;
        for (int sym1__ = 1; sym1__ <= NB_s; ++sym1__) {
          current_statement__ = 9;
          assign(theta_prevalence, theta_prevalence_flat__[(pos__ - 1)],
            "assigning variable theta_prevalence", index_uni(sym1__));
          current_statement__ = 9;
          pos__ = (pos__ + 1);
        }
      }
      Eigen::Matrix<double, -1, -1> delta_prevalence;
      delta_prevalence = Eigen::Matrix<double, -1, -1>(NB_s, NN);
      stan::math::fill(delta_prevalence, std::numeric_limits<double>::quiet_NaN());
      
      
      {
        std::vector<local_scalar_t__> delta_prevalence_flat__;
        current_statement__ = 10;
        delta_prevalence_flat__ = context__.vals_r("delta_prevalence");
        current_statement__ = 10;
        pos__ = 1;
        current_statement__ = 10;
        for (int sym1__ = 1; sym1__ <= NN; ++sym1__) {
          current_statement__ = 10;
          for (int sym2__ = 1; sym2__ <= NB_s; ++sym2__) {
            current_statement__ = 10;
            assign(delta_prevalence, delta_prevalence_flat__[(pos__ - 1)],
              "assigning variable delta_prevalence", index_uni(sym2__),
                                                       index_uni(sym1__));
            current_statement__ = 10;
            pos__ = (pos__ + 1);
          }
        }
      }
      Eigen::Matrix<double, -1, -1> delta_abundance;
      delta_abundance = Eigen::Matrix<double, -1, -1>(NB_s, NN);
      stan::math::fill(delta_abundance, std::numeric_limits<double>::quiet_NaN());
      
      
      {
        std::vector<local_scalar_t__> delta_abundance_flat__;
        current_statement__ = 11;
        delta_abundance_flat__ = context__.vals_r("delta_abundance");
        current_statement__ = 11;
        pos__ = 1;
        current_statement__ = 11;
        for (int sym1__ = 1; sym1__ <= NN; ++sym1__) {
          current_statement__ = 11;
          for (int sym2__ = 1; sym2__ <= NB_s; ++sym2__) {
            current_statement__ = 11;
            assign(delta_abundance, delta_abundance_flat__[(pos__ - 1)],
              "assigning variable delta_abundance", index_uni(sym2__),
                                                      index_uni(sym1__));
            current_statement__ = 11;
            pos__ = (pos__ + 1);
          }
        }
      }
      Eigen::Matrix<double, -1, -1> abundance_observed;
      abundance_observed = Eigen::Matrix<double, -1, -1>(NS, NT);
      stan::math::fill(abundance_observed, std::numeric_limits<double>::quiet_NaN());
      
      
      {
        std::vector<local_scalar_t__> abundance_observed_flat__;
        current_statement__ = 12;
        abundance_observed_flat__ = context__.vals_r("abundance_observed");
        current_statement__ = 12;
        pos__ = 1;
        current_statement__ = 12;
        for (int sym1__ = 1; sym1__ <= NT; ++sym1__) {
          current_statement__ = 12;
          for (int sym2__ = 1; sym2__ <= NS; ++sym2__) {
            current_statement__ = 12;
            assign(abundance_observed,
              abundance_observed_flat__[(pos__ - 1)],
              "assigning variable abundance_observed", index_uni(sym2__),
                                                         index_uni(sym1__));
            current_statement__ = 12;
            pos__ = (pos__ + 1);
          }
        }
      }
      Eigen::Matrix<double, -1, 1> multinomial_nuisance;
      multinomial_nuisance = Eigen::Matrix<double, -1, 1>(NS);
      stan::math::fill(multinomial_nuisance, std::numeric_limits<double>::quiet_NaN());
      
      
      {
        std::vector<local_scalar_t__> multinomial_nuisance_flat__;
        current_statement__ = 13;
        multinomial_nuisance_flat__ = context__.vals_r("multinomial_nuisance");
        current_statement__ = 13;
        pos__ = 1;
        current_statement__ = 13;
        for (int sym1__ = 1; sym1__ <= NS; ++sym1__) {
          current_statement__ = 13;
          assign(multinomial_nuisance,
            multinomial_nuisance_flat__[(pos__ - 1)],
            "assigning variable multinomial_nuisance", index_uni(sym1__));
          current_statement__ = 13;
          pos__ = (pos__ + 1);
        }
      }
      double inv_log_less_contamination;
      inv_log_less_contamination = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 14;
      inv_log_less_contamination = context__.vals_r("inv_log_less_contamination")[
          (1 - 1)];
      double inv_log_less_contamination_free__;
      inv_log_less_contamination_free__ = std::numeric_limits<double>::quiet_NaN();
      
      
      current_statement__ = 14;
      inv_log_less_contamination_free__ = stan::math::ub_free(
                                            inv_log_less_contamination, 0);
      double contaminant_overdisp;
      contaminant_overdisp = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 15;
      contaminant_overdisp = context__.vals_r("contaminant_overdisp")[
          (1 - 1)];
      double contaminant_overdisp_free__;
      contaminant_overdisp_free__ = std::numeric_limits<double>::quiet_NaN();
      
      current_statement__ = 15;
      contaminant_overdisp_free__ = stan::math::lb_free(contaminant_overdisp,
                                      0);
      for (int sym1__ = 1; sym1__ <= time_raw_1dim__; ++sym1__) {
        vars__.emplace_back(time_raw_free__[(sym1__ - 1)]);
      }
      vars__.emplace_back(seq_div_rate_free__);
      vars__.emplace_back(global_scale_prevalence_free__);
      vars__.emplace_back(global_scale_abundance_free__);
      for (int sym1__ = 1; sym1__ <= (var_prop_prevalence_1dim__ - 1);
           ++sym1__) {
        vars__.emplace_back(var_prop_prevalence_free__[(sym1__ - 1)]);
      }
      for (int sym1__ = 1; sym1__ <= (var_prop_abundance_1dim__ - 1);
           ++sym1__) {
        vars__.emplace_back(var_prop_abundance_free__[(sym1__ - 1)]);
      }
      for (int sym1__ = 1; sym1__ <= NSB; ++sym1__) {
        vars__.emplace_back(sigma_prevalence_free__[(sym1__ - 1)]);
      }
      for (int sym1__ = 1; sym1__ <= NSB; ++sym1__) {
        vars__.emplace_back(sigma_abundance_free__[(sym1__ - 1)]);
      }
      for (int sym1__ = 1; sym1__ <= NB_s; ++sym1__) {
        vars__.emplace_back(theta_prevalence[(sym1__ - 1)]);
      }
      for (int sym1__ = 1; sym1__ <= NN; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= NB_s; ++sym2__) {
          vars__.emplace_back(
            rvalue(delta_prevalence, "delta_prevalence",
              index_uni(sym2__), index_uni(sym1__)));
        }
      }
      for (int sym1__ = 1; sym1__ <= NN; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= NB_s; ++sym2__) {
          vars__.emplace_back(
            rvalue(delta_abundance, "delta_abundance",
              index_uni(sym2__), index_uni(sym1__)));
        }
      }
      for (int sym1__ = 1; sym1__ <= NT; ++sym1__) {
        for (int sym2__ = 1; sym2__ <= NS; ++sym2__) {
          vars__.emplace_back(
            rvalue(abundance_observed, "abundance_observed",
              index_uni(sym2__), index_uni(sym1__)));
        }
      }
      for (int sym1__ = 1; sym1__ <= NS; ++sym1__) {
        vars__.emplace_back(multinomial_nuisance[(sym1__ - 1)]);
      }
      vars__.emplace_back(inv_log_less_contamination_free__);
      vars__.emplace_back(contaminant_overdisp_free__);
    } catch (const std::exception& e) {
      stan::lang::rethrow_located(e, locations_array__[current_statement__]);
      // Next line prevents compiler griping about no return
      throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***"); 
    }
    } // transform_inits_impl() 
    
  inline void get_param_names(std::vector<std::string>& names__) const {
    
    names__ = std::vector<std::string>{"time_raw", "seq_div_rate",
      "global_scale_prevalence", "global_scale_abundance",
      "var_prop_prevalence", "var_prop_abundance", "sigma_prevalence",
      "sigma_abundance", "theta_prevalence", "delta_prevalence",
      "delta_abundance", "abundance_observed", "multinomial_nuisance",
      "inv_log_less_contamination", "contaminant_overdisp", "time_absolute",
      "time", "time_sqrt", "time_log", "log_less_contamination",
      "sd_prevalence", "sd_abundance", "alpha_prevalence_log",
      "alpha_abundance_log", "alpha_prevalence", "alpha_abundance",
      "beta_prevalence", "beta_abundance"};
    
    } // get_param_names() 
    
  inline void get_dims(std::vector<std::vector<size_t>>& dimss__) const {
    
    dimss__ = std::vector<std::vector<size_t>>{std::vector<size_t>{
                                                                   static_cast<size_t>(time_raw_1dim__)
                                                                   },
      std::vector<size_t>{}, std::vector<size_t>{}, std::vector<size_t>{
      },
      std::vector<size_t>{static_cast<size_t>(var_prop_prevalence_1dim__)},
      std::vector<size_t>{static_cast<size_t>(var_prop_abundance_1dim__)},
      std::vector<size_t>{static_cast<size_t>(NSB)},
      std::vector<size_t>{static_cast<size_t>(NSB)},
      std::vector<size_t>{static_cast<size_t>(NB_s)},
      std::vector<size_t>{static_cast<size_t>(NB_s), static_cast<size_t>(NN)},
      std::vector<size_t>{static_cast<size_t>(NB_s), static_cast<size_t>(NN)},
      std::vector<size_t>{static_cast<size_t>(NS), static_cast<size_t>(NT)},
      std::vector<size_t>{static_cast<size_t>(NS)}, std::vector<size_t>{
      }, std::vector<size_t>{}, std::vector<size_t>{static_cast<size_t>(NN)},
      std::vector<size_t>{static_cast<size_t>(NN)},
      std::vector<size_t>{static_cast<size_t>(NN)},
      std::vector<size_t>{static_cast<size_t>(NN)}, std::vector<size_t>{
      }, std::vector<size_t>{static_cast<size_t>(sd_prevalence_1dim__)},
      std::vector<size_t>{static_cast<size_t>(sd_abundance_1dim__)},
      std::vector<size_t>{static_cast<size_t>(NSB)},
      std::vector<size_t>{static_cast<size_t>(NSB)},
      std::vector<size_t>{static_cast<size_t>(NSB)},
      std::vector<size_t>{static_cast<size_t>(NSB)},
      std::vector<size_t>{static_cast<size_t>(NB_s), static_cast<size_t>(NN)},
      std::vector<size_t>{static_cast<size_t>(NB_s), static_cast<size_t>(NN)}};
    
    } // get_dims() 
    
  inline void constrained_param_names(
                                      std::vector<std::string>& param_names__,
                                      bool emit_transformed_parameters__ = true,
                                      bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= time_raw_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "time_raw" + '.' + std::to_string(sym1__));
      } 
    }
    param_names__.emplace_back(std::string() + "seq_div_rate");
    param_names__.emplace_back(std::string() + "global_scale_prevalence");
    param_names__.emplace_back(std::string() + "global_scale_abundance");
    for (int sym1__ = 1; sym1__ <= var_prop_prevalence_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "var_prop_prevalence" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= var_prop_abundance_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "var_prop_abundance" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= NSB; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "sigma_prevalence" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= NSB; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "sigma_abundance" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= NB_s; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "theta_prevalence" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= NN; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= NB_s; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "delta_prevalence" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    for (int sym1__ = 1; sym1__ <= NN; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= NB_s; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "delta_abundance" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    for (int sym1__ = 1; sym1__ <= NT; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= NS; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "abundance_observed" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    for (int sym1__ = 1; sym1__ <= NS; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "multinomial_nuisance" + '.' + std::to_string(sym1__));
      } 
    }
    param_names__.emplace_back(std::string() + "inv_log_less_contamination");
    param_names__.emplace_back(std::string() + "contaminant_overdisp");
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= NN; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "time_absolute" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= NN; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "time" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= NN; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "time_sqrt" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= NN; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "time_log" + '.' + std::to_string(sym1__));
        } 
      }
      param_names__.emplace_back(std::string() + "log_less_contamination");
      for (int sym1__ = 1; sym1__ <= sd_prevalence_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "sd_prevalence" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= sd_abundance_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "sd_abundance" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= NSB; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "alpha_prevalence_log" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= NSB; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "alpha_abundance_log" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= NSB; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "alpha_prevalence" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= NSB; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "alpha_abundance" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= NN; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= NB_s; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "beta_prevalence" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= NN; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= NB_s; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "beta_abundance" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // constrained_param_names() 
    
  inline void unconstrained_param_names(
                                        std::vector<std::string>& param_names__,
                                        bool emit_transformed_parameters__ = true,
                                        bool emit_generated_quantities__ = true) const
    final {
    
    for (int sym1__ = 1; sym1__ <= time_raw_1dim__; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "time_raw" + '.' + std::to_string(sym1__));
      } 
    }
    param_names__.emplace_back(std::string() + "seq_div_rate");
    param_names__.emplace_back(std::string() + "global_scale_prevalence");
    param_names__.emplace_back(std::string() + "global_scale_abundance");
    for (int sym1__ = 1; sym1__ <= (var_prop_prevalence_1dim__ - 1); ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "var_prop_prevalence" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= (var_prop_abundance_1dim__ - 1); ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "var_prop_abundance" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= NSB; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "sigma_prevalence" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= NSB; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "sigma_abundance" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= NB_s; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "theta_prevalence" + '.' + std::to_string(sym1__));
      } 
    }
    for (int sym1__ = 1; sym1__ <= NN; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= NB_s; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "delta_prevalence" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    for (int sym1__ = 1; sym1__ <= NN; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= NB_s; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "delta_abundance" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    for (int sym1__ = 1; sym1__ <= NT; ++sym1__) {
      {
        for (int sym2__ = 1; sym2__ <= NS; ++sym2__) {
          {
            param_names__.emplace_back(std::string() + "abundance_observed" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
          } 
        }
      } 
    }
    for (int sym1__ = 1; sym1__ <= NS; ++sym1__) {
      {
        param_names__.emplace_back(std::string() + "multinomial_nuisance" + '.' + std::to_string(sym1__));
      } 
    }
    param_names__.emplace_back(std::string() + "inv_log_less_contamination");
    param_names__.emplace_back(std::string() + "contaminant_overdisp");
    if (emit_transformed_parameters__) {
      for (int sym1__ = 1; sym1__ <= NN; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "time_absolute" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= NN; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "time" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= NN; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "time_sqrt" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= NN; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "time_log" + '.' + std::to_string(sym1__));
        } 
      }
      param_names__.emplace_back(std::string() + "log_less_contamination");
      for (int sym1__ = 1; sym1__ <= sd_prevalence_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "sd_prevalence" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= sd_abundance_1dim__; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "sd_abundance" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= NSB; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "alpha_prevalence_log" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= NSB; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "alpha_abundance_log" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= NSB; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "alpha_prevalence" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= NSB; ++sym1__) {
        {
          param_names__.emplace_back(std::string() + "alpha_abundance" + '.' + std::to_string(sym1__));
        } 
      }
      for (int sym1__ = 1; sym1__ <= NN; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= NB_s; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "beta_prevalence" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
      for (int sym1__ = 1; sym1__ <= NN; ++sym1__) {
        {
          for (int sym2__ = 1; sym2__ <= NB_s; ++sym2__) {
            {
              param_names__.emplace_back(std::string() + "beta_abundance" + '.' + std::to_string(sym2__) + '.' + std::to_string(sym1__));
            } 
          }
        } 
      }
    }
    
    if (emit_generated_quantities__) {
      
    }
    
    } // unconstrained_param_names() 
    
  inline std::string get_constrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"time_raw\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(time_raw_1dim__) + "},\"block\":\"parameters\"},{\"name\":\"seq_div_rate\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"global_scale_prevalence\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"global_scale_abundance\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"var_prop_prevalence\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(var_prop_prevalence_1dim__) + "},\"block\":\"parameters\"},{\"name\":\"var_prop_abundance\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(var_prop_abundance_1dim__) + "},\"block\":\"parameters\"},{\"name\":\"sigma_prevalence\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(NSB) + "},\"block\":\"parameters\"},{\"name\":\"sigma_abundance\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(NSB) + "},\"block\":\"parameters\"},{\"name\":\"theta_prevalence\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(NB_s) + "},\"block\":\"parameters\"},{\"name\":\"delta_prevalence\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(NB_s) + ",\"cols\":" + std::to_string(NN) + "},\"block\":\"parameters\"},{\"name\":\"delta_abundance\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(NB_s) + ",\"cols\":" + std::to_string(NN) + "},\"block\":\"parameters\"},{\"name\":\"abundance_observed\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(NS) + ",\"cols\":" + std::to_string(NT) + "},\"block\":\"parameters\"},{\"name\":\"multinomial_nuisance\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(NS) + "},\"block\":\"parameters\"},{\"name\":\"inv_log_less_contamination\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"contaminant_overdisp\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"time_absolute\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(NN) + "},\"block\":\"transformed_parameters\"},{\"name\":\"time\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(NN) + "},\"block\":\"transformed_parameters\"},{\"name\":\"time_sqrt\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(NN) + "},\"block\":\"transformed_parameters\"},{\"name\":\"time_log\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(NN) + "},\"block\":\"transformed_parameters\"},{\"name\":\"log_less_contamination\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"sd_prevalence\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(sd_prevalence_1dim__) + "},\"block\":\"transformed_parameters\"},{\"name\":\"sd_abundance\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(sd_abundance_1dim__) + "},\"block\":\"transformed_parameters\"},{\"name\":\"alpha_prevalence_log\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(NSB) + "},\"block\":\"transformed_parameters\"},{\"name\":\"alpha_abundance_log\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(NSB) + "},\"block\":\"transformed_parameters\"},{\"name\":\"alpha_prevalence\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(NSB) + "},\"block\":\"transformed_parameters\"},{\"name\":\"alpha_abundance\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(NSB) + "},\"block\":\"transformed_parameters\"},{\"name\":\"beta_prevalence\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(NB_s) + ",\"cols\":" + std::to_string(NN) + "},\"block\":\"transformed_parameters\"},{\"name\":\"beta_abundance\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(NB_s) + ",\"cols\":" + std::to_string(NN) + "},\"block\":\"transformed_parameters\"}]");
    
    } // get_constrained_sizedtypes() 
    
  inline std::string get_unconstrained_sizedtypes() const {
    
    return std::string("[{\"name\":\"time_raw\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(time_raw_1dim__) + "},\"block\":\"parameters\"},{\"name\":\"seq_div_rate\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"global_scale_prevalence\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"global_scale_abundance\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"var_prop_prevalence\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string((var_prop_prevalence_1dim__ - 1)) + "},\"block\":\"parameters\"},{\"name\":\"var_prop_abundance\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string((var_prop_abundance_1dim__ - 1)) + "},\"block\":\"parameters\"},{\"name\":\"sigma_prevalence\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(NSB) + "},\"block\":\"parameters\"},{\"name\":\"sigma_abundance\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(NSB) + "},\"block\":\"parameters\"},{\"name\":\"theta_prevalence\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(NB_s) + "},\"block\":\"parameters\"},{\"name\":\"delta_prevalence\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(NB_s) + ",\"cols\":" + std::to_string(NN) + "},\"block\":\"parameters\"},{\"name\":\"delta_abundance\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(NB_s) + ",\"cols\":" + std::to_string(NN) + "},\"block\":\"parameters\"},{\"name\":\"abundance_observed\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(NS) + ",\"cols\":" + std::to_string(NT) + "},\"block\":\"parameters\"},{\"name\":\"multinomial_nuisance\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(NS) + "},\"block\":\"parameters\"},{\"name\":\"inv_log_less_contamination\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"contaminant_overdisp\",\"type\":{\"name\":\"real\"},\"block\":\"parameters\"},{\"name\":\"time_absolute\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(NN) + "},\"block\":\"transformed_parameters\"},{\"name\":\"time\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(NN) + "},\"block\":\"transformed_parameters\"},{\"name\":\"time_sqrt\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(NN) + "},\"block\":\"transformed_parameters\"},{\"name\":\"time_log\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(NN) + "},\"block\":\"transformed_parameters\"},{\"name\":\"log_less_contamination\",\"type\":{\"name\":\"real\"},\"block\":\"transformed_parameters\"},{\"name\":\"sd_prevalence\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(sd_prevalence_1dim__) + "},\"block\":\"transformed_parameters\"},{\"name\":\"sd_abundance\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(sd_abundance_1dim__) + "},\"block\":\"transformed_parameters\"},{\"name\":\"alpha_prevalence_log\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(NSB) + "},\"block\":\"transformed_parameters\"},{\"name\":\"alpha_abundance_log\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(NSB) + "},\"block\":\"transformed_parameters\"},{\"name\":\"alpha_prevalence\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(NSB) + "},\"block\":\"transformed_parameters\"},{\"name\":\"alpha_abundance\",\"type\":{\"name\":\"vector\",\"length\":" + std::to_string(NSB) + "},\"block\":\"transformed_parameters\"},{\"name\":\"beta_prevalence\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(NB_s) + ",\"cols\":" + std::to_string(NN) + "},\"block\":\"transformed_parameters\"},{\"name\":\"beta_abundance\",\"type\":{\"name\":\"matrix\",\"rows\":" + std::to_string(NB_s) + ",\"cols\":" + std::to_string(NN) + "},\"block\":\"transformed_parameters\"}]");
    
    } // get_unconstrained_sizedtypes() 
    
  
    // Begin method overload boilerplate
    template <typename RNG>
    inline void write_array(RNG& base_rng,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                            Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                            const bool emit_transformed_parameters = true,
                            const bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      std::vector<double> vars_vec;
      vars_vec.reserve(vars.size());
      std::vector<int> params_i;
      write_array_impl(base_rng, params_r, params_i, vars_vec,
          emit_transformed_parameters, emit_generated_quantities, pstream);
      vars = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        vars_vec.data(), vars_vec.size());
    }

    template <typename RNG>
    inline void write_array(RNG& base_rng, std::vector<double>& params_r,
                            std::vector<int>& params_i,
                            std::vector<double>& vars,
                            bool emit_transformed_parameters = true,
                            bool emit_generated_quantities = true,
                            std::ostream* pstream = nullptr) const {
      write_array_impl(base_rng, params_r, params_i, vars,
       emit_transformed_parameters, emit_generated_quantities, pstream);
    }

    template <bool propto__, bool jacobian__, typename T_>
    inline T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
                       std::ostream* pstream = nullptr) const {
      Eigen::Matrix<int, -1, 1> params_i;
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }

    template <bool propto__, bool jacobian__, typename T__>
    inline T__ log_prob(std::vector<T__>& params_r,
                        std::vector<int>& params_i,
                        std::ostream* pstream = nullptr) const {
      return log_prob_impl<propto__, jacobian__>(params_r, params_i, pstream);
    }


    inline void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream = nullptr) const final {
      std::vector<double> params_r_vec;
      params_r_vec.reserve(params_r.size());
      std::vector<int> params_i;
      transform_inits_impl(context, params_i, params_r_vec, pstream);
      params_r = Eigen::Map<Eigen::Matrix<double,Eigen::Dynamic,1>>(
        params_r_vec.data(), params_r_vec.size());
    }
    inline void transform_inits(const stan::io::var_context& context,
                                std::vector<int>& params_i,
                                std::vector<double>& vars,
                                std::ostream* pstream = nullptr) const final {
      transform_inits_impl(context, params_i, vars, pstream);
    }

};
}
using stan_model = lvip_glm_model_namespace::lvip_glm_model;

#ifndef USING_R

// Boilerplate
stan::model::model_base& new_model(
        stan::io::var_context& data_context,
        unsigned int seed,
        std::ostream* msg_stream) {
  stan_model* m = new stan_model(data_context, seed, msg_stream);
  return *m;
}

stan::math::profile_map& get_stan_profile_data() {
  return lvip_glm_model_namespace::profiles__;
}

#endif


